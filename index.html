<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Charm Design Questionnaire</title>
    <script src="config.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Avenir Next', 'Avenir', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 300;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border: 1px solid #000000;
            box-shadow: 0 0 0 1px #000000;
            max-width: 600px;
            width: 100%;
            padding: 40px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #f0f0f0;
        }

        .progress-fill {
            height: 100%;
            background: #000000;
            width: 0%;
            transition: width 0.5s ease;
        }

        .question-container {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .question-container.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #000000;
            margin-bottom: 10px;
            font-size: 28px;
            font-weight: 300;
            letter-spacing: -0.5px;
        }

        h2 {
            color: #000000;
            margin-bottom: 30px;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: -0.3px;
        }

        p {
            color: #000000;
            margin-bottom: 30px;
            font-size: 18px;
            line-height: 1.6;
            font-weight: 300;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .option {
            padding: 20px;
            border: 1px solid #000000;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            text-align: left;
            background: #ffffff;
            font-weight: 300;
            position: relative;
        }

        .option::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0;
            background: #DAE0FF;
            transition: width 0.3s ease;
            z-index: -1;
        }

        .option:hover::after {
            width: 100%;
        }

        .option:hover {
            transform: translateX(5px);
        }

        .option:hover {
            transform: translateX(5px);
        }

        .option.selected {
            background: #DAE0FF;
            border: 2px solid #000000;
            padding: 19px;
            animation: selectPulse 0.3s ease;
        }

        @keyframes selectPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .multi-select .option.selected {
            background: #000000;
            color: #ffffff;
            border: 1px solid #000000;
            padding: 20px;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"],
        textarea {
            width: 100%;
            padding: 15px;
            border: 1px solid #000000;
            font-size: 16px;
            transition: border-color 0.3s ease;
            font-family: inherit;
            background: #ffffff;
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        input[type="tel"]:focus,
        textarea:focus {
            outline: none;
            border: 2px solid #000000;
            padding: 14px;
            background: #DAE0FF;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
            margin-bottom: 20px;
        }

        .file-upload input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-upload-label {
            display: block;
            padding: 40px 20px;
            border: 3px dashed #000000;
            text-align: center;
            color: #000000;
            transition: all 0.3s ease;
            background: #ffffff;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 400;
            position: relative;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .file-upload-label::before {
            content: "( ^ _ ^ )";
            font-size: 24px;
            display: block;
            margin-bottom: 8px;
            font-family: monospace;
        }

        .file-upload:hover .file-upload-label {
            background: #DAE0FF;
            border-color: #000000;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .file-upload-label.drag-over {
            background: #DAE0FF !important;
            border-color: #000000 !important;
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .file-upload.drag-active {
            background: rgba(218, 224, 255, 0.1);
            border-radius: 8px;
        }

        .file-upload-instructions {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
            font-weight: 300;
        }

        .file-info {
            margin-top: 10px;
            color: #000000;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 30px;
            justify-content: flex-end;
        }

        button {
            padding: 12px 20px;
            border: 1px solid #cccccc;
            font-size: 16px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 0 0 auto;
            background: #ffffff;
            color: #666666;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 44px;
            max-width: 60px;
        }

        button svg {
            width: 16px;
            height: 16px;
            transition: transform 0.3s ease;
        }

        button:hover svg {
            transform: translateX(3px);
        }

        .btn-secondary:hover svg {
            transform: translateX(-3px);
        }

        .btn-primary {
            background: #f8f8f8;
            color: #333333;
            border: 1px solid #dddddd;
        }

        .btn-primary:hover {
            background: #DAE0FF;
            color: #000000;
            border: 1px solid #000000;
        }

        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #f5f5f5;
            color: #cccccc;
            border: 1px solid #eeeeee;
        }

        .btn-secondary {
            background: #ffffff;
            color: #666666;
            border: 1px solid #dddddd;
        }

        .btn-secondary:hover {
            background: #f0f0f0;
            color: #333333;
            border: 1px solid #999999;
        }

        .skip-link {
            text-align: center;
            margin-top: 15px;
            color: #000000;
            font-size: 14px;
        }

        .skip-link a {
            color: #000000;
            text-decoration: underline;
        }

        .skip-link a:hover {
            background: #DAE0FF;
            text-decoration: none;
        }

        .results {
            background: #DAE0FF;
            padding: 30px;
            margin-top: 30px;
            border: 1px solid #000000;
        }

        .results h3 {
            color: #000000;
            margin-bottom: 20px;
        }

        .results-list {
            list-style: none;
        }

        .results-list li {
            padding: 10px 0;
            border-bottom: 1px solid #000000;
        }

        .results-list li:last-child {
            border-bottom: none;
        }

        .results-list strong {
            color: #000000;
            display: inline-block;
            min-width: 150px;
        }

        .completion-message {
            text-align: center;
            padding: 40px;
        }

        .completion-message h1 {
            color: #000000;
            margin-bottom: 20px;
        }

        .completion-message p {
            font-size: 20px;
            color: #000000;
        }



        @media (max-width: 600px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 24px;
            }

            h2 {
                font-size: 20px;
            }

            p {
                font-size: 16px;
            }

            .option {
                padding: 15px;
                font-size: 15px;
            }


        }
    </style>
</head>
<body>
    <div class="container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>



        <!-- Question 1 -->
        <div class="question-container active" data-question="Q1">
            <h2>Let's create your custom charm</h2>
            <p>How much do you already know about what you want?</p>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'A')">
                    I need help with ideas
                </div>
                <div class="option" onclick="selectOption(this, 'B')">
                    I have some ideas
                </div>
                <div class="option" onclick="selectOption(this, 'C')">
                    I know exactly what I want
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="handleQ1Branch()" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Path C: Q2 -->
        <div class="question-container" data-question="Q2">
            <h2>Perfect! Show me your inspiration</h2>
            <p>Upload any photo, sketch, or reference image</p>
            <div class="file-upload">
                <input type="file" id="q2-file" accept="image/*" onchange="handleFileUpload('q2-file')">
                <label for="q2-file" class="file-upload-label">
                    <strong>Drag & drop your image here</strong>
                    <span class="file-upload-instructions">or click to browse your files</span>
                </label>
                <div class="file-info" id="q2-file-info"></div>
            </div>
            <div class="skip-link">
                <a href="#" onclick="skipUpload(); return false;">I'll describe it instead</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                </button>
                <button class="btn-primary" onclick="nextQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Path A: Q3 -->
        <div class="question-container" data-question="Q3">
            <h2>What's the story behind your charm?</h2>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'curious')">
                    Just browsing for something beautiful
                </div>
                <div class="option" onclick="selectOption(this, 'moment')">
                    Celebrating a special moment
                </div>
                <div class="option" onclick="selectOption(this, 'person')">
                    Honoring someone special
                </div>
                <div class="option" onclick="selectOption(this, 'place')">
                    Remembering a meaningful place
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Path A: Q4 -->
        <div class="question-container" data-question="Q4">
            <h2>Who will wear this charm?</h2>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'for-me')">
                    It's for me
                </div>
                <div class="option" onclick="selectOption(this, 'for-someone')">
                    A gift for someone special
                </div>
                <div class="option" onclick="selectOption(this, 'not-sure')">
                    Still deciding
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Paths C & B: Q5 & Q10 (same content, different IDs) -->
        <div class="question-container" data-question="Q5">
            <h2>What style appeals to you?</h2>
            <p>Choose all that feel right (you can select multiple)</p>
            <div class="options multi-select">
                <div class="option" onclick="toggleMultiSelect(this, 'elegant')">
                    Elegant & Timeless
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'bold')">
                    Bold & Confident
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'playful')">
                    Playful & Fun
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'spiritual')">
                    Spiritual & Meaningful
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'sweet')">
                    Sweet & Sentimental
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Path A: Q6 -->
        <div class="question-container" data-question="Q6">
            <h2>What feels meaningful to you?</h2>
            <p>Think about symbols, memories, or elements that hold special meaning</p>
            <textarea placeholder="For example: nature elements, meaningful symbols, initials, or something that represents your journey..."></textarea>
            <div class="skip-link">
                <a href="#" onclick="skipTextInput(); return false;">I'm still exploring - help me decide</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                </button>
                <button class="btn-primary" onclick="nextQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Path A: Q7 -->
        <div class="question-container" data-question="Q7">
            <h2>Do you have any inspiration photos? (optional)</h2>
            <div class="file-upload">
                <input type="file" id="q7-file" accept="image/*" onchange="handleFileUpload('q7-file')">
                <label for="q7-file" class="file-upload-label">
                    <strong>Drag & drop inspiration photos here</strong>
                    <span class="file-upload-instructions">or click to browse your files</span>
                </label>
                <div class="file-info" id="q7-file-info"></div>
            </div>
            <div class="skip-link">
                <a href="#" onclick="skipUpload(); return false;">Skip this step</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">Continue</button>
            </div>
        </div>

        <!-- Path B: Q8 -->
        <div class="question-container" data-question="Q8">
            <h2>Tell me about your idea</h2>
            <textarea placeholder="Describe what you're envisioning... the more details, the better!"></textarea>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Path B: Q9 -->
        <div class="question-container" data-question="Q9">
            <h2>Upload any reference images (optional).</h2>
            <div class="file-upload">
                <input type="file" id="q9-file" accept="image/*" multiple onchange="handleFileUpload('q9-file')">
                <label for="q9-file" class="file-upload-label">
                    <strong>Drag & drop reference images here</strong>
                    <span class="file-upload-instructions">or click to browse your files (multiple files OK)</span>
                </label>
                <div class="file-info" id="q9-file-info"></div>
            </div>
            <div class="skip-link">
                <a href="#" onclick="skipUpload(); return false;">Skip this step</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">Continue</button>
            </div>
        </div>

        <!-- Path B: Q10 (duplicate of Q5) -->
        <div class="question-container" data-question="Q10">
            <h2>What style appeals to you?</h2>
            <p>Choose all that feel right (you can select multiple)</p>
            <div class="options multi-select">
                <div class="option" onclick="toggleMultiSelect(this, 'elegant')">
                    Elegant & Timeless
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'bold')">
                    Bold & Confident
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'playful')">
                    Playful & Cute
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'spiritual')">
                    Spiritual & Symbolic
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'sweet')">
                    Sweet & Sentimental
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Convergence: Q11 -->
        <div class="question-container" data-question="Q11">
            <h2>What size and presence do you prefer?</h2>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'subtle')">
                    Small & delicate
                </div>
                <div class="option" onclick="selectOption(this, 'bold-sculptural')">
                    Bold & statement-making
                </div>
                <div class="option" onclick="selectOption(this, 'classic')">
                    Medium & versatile
                </div>
                <div class="option" onclick="selectOption(this, 'not-sure')">
                    I'm not sure yet
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Q12 -->
        <div class="question-container" data-question="Q12">
            <h2>What material would you prefer?</h2>
            <p>Each option has different qualities and pricing</p>
            <div class="options">
                <div class="option" onclick="selectOption(this, '14k-gold')">
                    14K Solid Gold
                    <span style="display: block; font-size: 14px; margin-top: 5px; opacity: 0.7;">Luxurious & lasting</span>
                </div>
                <div class="option" onclick="selectOption(this, 'sterling-silver')">
                    Sterling Silver
                    <span style="display: block; font-size: 14px; margin-top: 5px; opacity: 0.7;">Classic & affordable</span>
                </div>
                <div class="option" onclick="selectOption(this, 'gold-plated')">
                    Gold-Plated Silver
                    <span style="display: block; font-size: 14px; margin-top: 5px; opacity: 0.7;">Golden look, silver price</span>
                </div>
                <div class="option" onclick="selectOption(this, 'help-decide')">
                    Help me choose
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Q13 -->
        <div class="question-container" data-question="Q13">
            <h2>Any special details or requests?</h2>
            <p style="color: #666; font-size: 16px; margin-bottom: 20px;">Amazing! Your custom design is taking shape. Any final touches?</p>
            <textarea placeholder="For example: specific dates, sizing preferences, engraving ideas, or any other notes..."></textarea>
            <div class="skip-link">
                <a href="#" onclick="skipTextInput(); return false;">No special requests</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                </button>
                <button class="btn-primary" onclick="nextQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Contact Info -->
        <div class="question-container" data-question="contact">
            <h2>How can we reach you?</h2>
            <p>We'll send your custom design mockup and updates</p>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 400; color: #000;">Email address *</label>
                <input type="email" id="contact-email" placeholder="your@email.com" required style="margin-bottom: 15px;">
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 400; color: #000;">Phone number (optional)</label>
                <input type="tel" id="contact-phone" placeholder="+1 (555) 123-4567">
                <div style="font-size: 14px; color: #666; margin-top: 5px;">For text updates when your design is ready</div>
            </div>
            
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                </button>
                <button class="btn-primary" onclick="validateContact()" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <div class="question-container" data-question="community">
            <h2>Can we feature your design in our gallery?</h2>
            <p>We love showcasing beautiful custom pieces to inspire other customers</p>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'yes')">
                    Yes, that sounds great!
                </div>
                <div class="option" onclick="selectOption(this, 'no')">
                    No, keep it private
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="submitForm()" disabled>
                    Submit
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Completion -->
        <div class="question-container" data-question="complete">
            <div class="completion-message">
                <h1>You're all set!</h1>
                <p>We'll craft your custom design and send it within 24-48 hours</p>
                <p style="font-size: 16px; margin-top: 20px;">Keep an eye on your inbox - you're going to love what we create together</p>
                <div class="results">
                    <h3>Your Design Summary:</h3>
                    <ul class="results-list" id="resultsList">
                        <!-- Results will be populated here -->
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        const formData = {};
        let questionFlow = ['Q1'];
        const questionHistory = [];

        function updateProgress() {
            const totalQuestions = questionFlow.length;
            const progress = ((currentQuestionIndex + 1) / totalQuestions) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function addArrowToButtons() {
            // Replace all button text with just arrows
            document.querySelectorAll('.btn-primary').forEach(btn => {
                if (btn.textContent.includes('Submit') || btn.innerHTML.includes('20 6 9 17 4 12')) {
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>`;
                } else {
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>`;
                }
            });
            
            document.querySelectorAll('.btn-secondary').forEach(btn => {
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>`;
            });
        }

        function showQuestion(questionId) {
            document.querySelectorAll('.question-container').forEach(container => {
                container.classList.remove('active');
            });
            
            const targetQuestion = document.querySelector(`[data-question="${questionId}"]`);
            if (targetQuestion) {
                targetQuestion.classList.add('active');
                // Add arrows to buttons in the active question
                setTimeout(addArrowToButtons, 10);
            }
            
            updateProgress();
            
            // Re-setup drag and drop for any new file upload areas
            setTimeout(() => {
                setupDragAndDrop();
            }, 100);
        }

        function nextQuestion() {
            const currentQuestion = questionFlow[currentQuestionIndex];
            
            // Save text inputs
            const textarea = document.querySelector(`.question-container.active textarea`);
            const emailInput = document.querySelector(`.question-container.active input[type="email"]`);
            const phoneInput = document.querySelector(`.question-container.active input[type="tel"]`);
            
            if (textarea) {
                formData[currentQuestion] = textarea.value;
            }
            if (emailInput) {
                formData.email = emailInput.value;
            }
            if (phoneInput) {
                formData.phone = phoneInput.value;
            }
            
            questionHistory.push(currentQuestionIndex);
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questionFlow.length) {
                showQuestion(questionFlow[currentQuestionIndex]);
            }
        }

        function previousQuestion() {
            if (questionHistory.length > 0) {
                currentQuestionIndex = questionHistory.pop();
                showQuestion(questionFlow[currentQuestionIndex]);
            }
        }

        function selectOption(element, value) {
            const container = element.parentElement;
            container.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            
            const questionId = element.closest('.question-container').dataset.question;
            formData[questionId] = value;
            
            // Enable continue button
            const continueBtn = element.closest('.question-container').querySelector('.btn-primary');
            if (continueBtn) {
                continueBtn.disabled = false;
            }
            
            // Auto-advance after a short delay
            setTimeout(() => {
                if (questionId === 'Q1') {
                    handleQ1Branch();
                } else if (questionId === 'community') {
                    submitForm();
                } else {
                    nextQuestion();
                }
            }, 300);
        }

        function toggleMultiSelect(element, value) {
            element.classList.toggle('selected');
            
            const questionId = element.closest('.question-container').dataset.question;
            if (!formData[questionId]) {
                formData[questionId] = [];
            }
            
            if (element.classList.contains('selected')) {
                formData[questionId].push(value);
            } else {
                formData[questionId] = formData[questionId].filter(v => v !== value);
            }
            
            // Enable continue button if at least one option is selected
            const continueBtn = element.closest('.question-container').querySelector('.btn-primary');
            if (continueBtn) {
                continueBtn.disabled = formData[questionId].length === 0;
            }
            
            // Auto-advance after selecting at least one option and a delay
            if (formData[questionId].length > 0) {
                clearTimeout(window.multiSelectTimer);
                window.multiSelectTimer = setTimeout(() => {
                    nextQuestion();
                }, 1000); // Slightly longer delay for multi-select
            }
        }

        function handleQ1Branch() {
            const answer = formData.Q1;
            
            // Build the appropriate flow based on the answer
            if (answer === 'A') {
                // Path A: Need help
                questionFlow = ['Q1', 'Q3', 'Q4', 'Q6', 'Q7', 'Q11', 'Q12', 'Q13', 'contact', 'community', 'complete'];
            } else if (answer === 'B') {
                // Path B: Have ideas
                questionFlow = ['Q1', 'Q8', 'Q9', 'Q10', 'Q11', 'Q12', 'Q13', 'contact', 'community', 'complete'];
            } else if (answer === 'C') {
                // Path C: Know exactly
                questionFlow = ['Q1', 'Q2', 'Q5', 'Q11', 'Q12', 'Q13', 'contact', 'community', 'complete'];
            }
            
            nextQuestion();
        }

        function handleFileUpload(inputId) {
            const fileInput = document.getElementById(inputId);
            const fileInfo = document.getElementById(inputId + '-info');
            
            if (fileInput.files.length > 0) {
                const newFiles = Array.from(fileInput.files);
                const questionId = fileInput.closest('.question-container').dataset.question;
                
                // Get existing files if any
                const existingFiles = formData[questionId + '_files'] || [];
                const existingBase64 = formData[questionId + '_base64'] || [];
                
                // Combine existing and new files
                const allFiles = [...existingFiles, ...newFiles];
                const allFileNames = allFiles.map(f => f.name).join(', ');
                
                // Update form data
                formData[questionId + '_files'] = allFiles;
                
                // Update file info display
                const fileCount = allFiles.length;
                fileInfo.innerHTML = `<div style="color: #000; font-weight: 400; margin: 10px 0;">:) ${fileCount} file${fileCount > 1 ? 's' : ''} selected: ${allFileNames}</div>`;
                
                // Convert new images to base64 and combine with existing
                convertFilesToBase64(newFiles, questionId, existingBase64);
                showImagePreviews(allFiles, fileInfo);
                
                // Update the upload label to show success and ability to add more
                const label = fileInput.nextElementSibling;
                label.style.background = '#d4edda';
                label.style.borderColor = '#28a745';
                label.innerHTML = `
                    <strong>:) ${fileCount} file${fileCount > 1 ? 's' : ''} uploaded!</strong>
                    <span class="file-upload-instructions">Click to add more files or replace all</span>
                `;
                
                // Add "Add More" button
                addMoreFilesButton(fileInput, questionId);
            }
        }

        function addMoreFilesButton(originalInput, questionId) {
            const container = originalInput.closest('.file-upload');
            
            // Remove existing buttons if they exist
            const existingButton = container.querySelector('.add-more-button');
            const existingClearButton = container.querySelector('.clear-all-button');
            const existingAdditionalInput = container.querySelector('input[type="file"][style*="display: none"]');
            
            if (existingButton) existingButton.remove();
            if (existingClearButton) existingClearButton.remove();
            if (existingAdditionalInput) existingAdditionalInput.remove();
            
            // Remove button container if it exists
            const existingButtonContainer = container.querySelector('div[style*="display: flex"]');
            if (existingButtonContainer) existingButtonContainer.remove();
            
            // Create "Add More" button
            const addMoreButton = document.createElement('button');
            addMoreButton.className = 'add-more-button';
            addMoreButton.type = 'button';
            addMoreButton.style.cssText = `
                margin-top: 10px;
                padding: 8px 16px;
                background: #f8f8f8;
                border: 1px solid #ddd;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            `;
            addMoreButton.innerHTML = '+ Add More Images';
            
            // Add hover effects
            addMoreButton.onmouseover = function() {
                this.style.background = '#DAE0FF';
                this.style.borderColor = '#000';
            };
            addMoreButton.onmouseout = function() {
                this.style.background = '#f8f8f8';
                this.style.borderColor = '#ddd';
            };
            
            // Create hidden file input for additional files
            const additionalInput = document.createElement('input');
            additionalInput.type = 'file';
            additionalInput.accept = 'image/*';
            additionalInput.multiple = true;
            additionalInput.style.display = 'none';
            
            // Handle additional file selection
            additionalInput.onchange = function() {
                if (this.files.length > 0) {
                    const newFiles = Array.from(this.files);
                    const existingFiles = formData[questionId + '_files'] || [];
                    const existingBase64 = formData[questionId + '_base64'] || [];
                    
                    // Combine files
                    const allFiles = [...existingFiles, ...newFiles];
                    formData[questionId + '_files'] = allFiles;
                    
                    // Update display
                    const fileInfo = document.getElementById(originalInput.id + '-info');
                    const allFileNames = allFiles.map(f => f.name).join(', ');
                    const fileCount = allFiles.length;
                    fileInfo.innerHTML = `<div style="color: #000; font-weight: 400; margin: 10px 0;">:) ${fileCount} file${fileCount > 1 ? 's' : ''} selected: ${allFileNames}</div>`;
                    
                    // Convert new images and update previews
                    convertFilesToBase64(newFiles, questionId, existingBase64);
                    showImagePreviews(allFiles, fileInfo);
                    
                    // Update main label
                    const label = originalInput.nextElementSibling;
                    label.innerHTML = `
                        <strong>:) ${fileCount} file${fileCount > 1 ? 's' : ''} uploaded!</strong>
                        <span class="file-upload-instructions">Click to add more files or replace all</span>
                    `;
                    
                    // Reset the additional input for next use
                    this.value = '';
                }
            };
            
            // Click handler for the button
            addMoreButton.onclick = function() {
                additionalInput.click();
            };
            
            // Create "Clear All" button
            const clearButton = document.createElement('button');
            clearButton.className = 'clear-all-button';
            clearButton.type = 'button';
            clearButton.style.cssText = `
                margin-top: 10px;
                margin-left: 10px;
                padding: 8px 16px;
                background: #fff;
                border: 1px solid #ddd;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
                color: #666;
            `;
            clearButton.innerHTML = 'Clear All';
            
            // Add hover effects for clear button
            clearButton.onmouseover = function() {
                this.style.background = '#ffebee';
                this.style.borderColor = '#f44336';
                this.style.color = '#f44336';
            };
            clearButton.onmouseout = function() {
                this.style.background = '#fff';
                this.style.borderColor = '#ddd';
                this.style.color = '#666';
            };
            
            // Clear all files handler
            clearButton.onclick = function() {
                if (confirm('Are you sure you want to remove all uploaded images?')) {
                    // Clear form data
                    formData[questionId + '_files'] = [];
                    formData[questionId + '_base64'] = [];
                    
                    // Reset original input
                    originalInput.value = '';
                    
                    // Reset label
                    const label = originalInput.nextElementSibling;
                    label.style.background = '#ffffff';
                    label.style.borderColor = '#000000';
                    label.innerHTML = `
                        <strong>Drag & drop your images here</strong>
                        <span class="file-upload-instructions">or click to browse your files</span>
                    `;
                    
                    // Clear file info
                    const fileInfo = document.getElementById(originalInput.id + '-info');
                    fileInfo.innerHTML = '';
                    
                    // Remove preview containers
                    const existingContainers = container.querySelectorAll('.image-preview-container');
                    existingContainers.forEach(cont => cont.remove());
                    
                    // Remove buttons
                    addMoreButton.remove();
                    clearButton.remove();
                    additionalInput.remove();
                }
            };
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; align-items: center;';
            buttonContainer.appendChild(addMoreButton);
            buttonContainer.appendChild(clearButton);
            
            // Add elements to container
            container.appendChild(additionalInput);
            container.appendChild(buttonContainer);
        }

        // Drag and drop functionality - fixed version
        function setupDragAndDrop() {
            console.log('Setting up drag and drop...');
            
            // Remove any existing global listeners first
            document.removeEventListener('dragover', preventDefaults);
            document.removeEventListener('drop', preventDefaults);
            
            // Add global prevention of default behaviors
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            document.addEventListener('dragover', preventDefaults);
            document.addEventListener('drop', preventDefaults);
            
            // Get all file upload containers
            const uploadContainers = document.querySelectorAll('.file-upload');
            console.log('Found upload containers:', uploadContainers.length);
            
            uploadContainers.forEach((container, index) => {
                const fileInput = container.querySelector('input[type="file"]');
                if (!fileInput) {
                    console.log('No file input found in container', index);
                    return;
                }
                
                const inputId = fileInput.id;
                const label = container.querySelector('.file-upload-label');
                
                console.log('Setting up drag and drop for:', inputId);
                
                // Clear any existing event listeners by cloning and replacing
                const newContainer = container.cloneNode(true);
                container.parentNode.replaceChild(newContainer, container);
                
                // Get references to the new elements
                const newFileInput = newContainer.querySelector('input[type="file"]');
                const newLabel = newContainer.querySelector('.file-upload-label');
                
                // Re-attach the file change handler
                newFileInput.addEventListener('change', function() {
                    handleFileUpload(this.id);
                });
                
                // Drag enter
                newContainer.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Drag enter on:', inputId);
                    
                    if (newLabel) {
                        newLabel.classList.add('drag-over');
                        newContainer.classList.add('drag-active');
                    }
                });
                
                // Drag over
                newContainer.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'copy';
                });
                
                // Drag leave
                newContainer.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if we're really leaving the container
                    const rect = newContainer.getBoundingClientRect();
                    const x = e.clientX;
                    const y = e.clientY;
                    
                    if (x <= rect.left || x >= rect.right || y <= rect.top || y >= rect.bottom) {
                        console.log('Drag leave on:', inputId);
                        if (newLabel) {
                            newLabel.classList.remove('drag-over');
                            newContainer.classList.remove('drag-active');
                        }
                    }
                });
                
                // Drop
                newContainer.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Drop event triggered on:', inputId);
                    
                    if (newLabel) {
                        newLabel.classList.remove('drag-over');
                        newContainer.classList.remove('drag-active');
                    }
                    
                    const files = e.dataTransfer.files;
                    console.log('Files dropped:', files.length);
                    
                    if (files && files.length > 0) {
                        const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                        console.log('Image files found:', imageFiles.length);
                        
                        if (imageFiles.length > 0) {
                            // Create a new DataTransfer object to set files
                            const dt = new DataTransfer();
                            
                            // Get existing files if any
                            const existingFiles = formData[inputId.replace('-file', '') + '_files'] || [];
                            
                            // Add existing files first
                            existingFiles.forEach(file => {
                                dt.items.add(file);
                            });
                            
                            // Add new files
                            imageFiles.forEach(file => {
                                dt.items.add(file);
                            });
                            
                            // Set the files on the input
                            newFileInput.files = dt.files;
                            
                            // Trigger the upload handler
                            console.log('Triggering handleFileUpload for:', inputId);
                            handleFileUpload(inputId);
                        } else {
                            alert('Please drop only image files (JPG, PNG, GIF, etc.)');
                        }
                    }
                });
            });
        }

        function showImagePreviews(files, fileInfo) {
            // Clear existing previews and containers
            const existingPreviews = fileInfo.parentElement.querySelectorAll('.image-preview');
            const existingContainers = fileInfo.parentElement.querySelectorAll('.image-preview-container');
            existingPreviews.forEach(preview => preview.remove());
            existingContainers.forEach(container => container.remove());
            
            // Create a container for all previews
            const previewContainer = document.createElement('div');
            previewContainer.className = 'image-preview-container';
            previewContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; justify-content: center;';
            
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'image-preview';
                        previewDiv.style.cssText = 'text-align: center; flex: 0 0 auto;';
                        previewDiv.innerHTML = `
                            <img src="${e.target.result}" alt="Preview" style="max-width: 120px; max-height: 120px; border: 2px solid #000; border-radius: 8px; object-fit: cover;">
                            <p style="font-size: 11px; color: #666; margin: 5px 0 0 0; max-width: 120px; word-break: break-word;">${file.name}</p>
                        `;
                        previewContainer.appendChild(previewDiv);
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            fileInfo.parentElement.appendChild(previewContainer);
        }

        async function convertFilesToBase64(files, questionId, existingBase64 = []) {
            const newBase64Images = [];
            
            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    try {
                        const base64 = await fileToBase64(file);
                        newBase64Images.push(base64);
                    } catch (error) {
                        console.error('Error converting file to base64:', error);
                    }
                }
            }
            
            if (newBase64Images.length > 0) {
                // Combine existing and new base64 images
                const allBase64Images = [...existingBase64, ...newBase64Images];
                formData[questionId + '_base64'] = allBase64Images;
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        function skipUpload() {
            const currentQuestion = document.querySelector('.question-container.active').dataset.question;
            
            if (currentQuestion === 'Q2') {
                // Path C: Skip upload and go to describe idea (Q8), then size (Q11)
                questionFlow = ['Q1', 'Q2', 'Q8', 'Q11', 'Q12', 'Q13', 'contact', 'community', 'complete'];
                // Jump to Q8 (Tell me about your idea)
                currentQuestionIndex = 2; // Q8 is at index 2 in the new flow
                showQuestion('Q8');
            } else {
                // For other upload questions, just continue normally
                nextQuestion();
            }
        }

        function skipTextInput() {
            const textarea = document.querySelector('.question-container.active textarea');
            if (textarea) {
                textarea.value = '';
            }
            nextQuestion();
        }

        function skipPhone() {
            formData.phone = '';
            nextQuestion();
        }

        function validateContact() {
            const emailInput = document.querySelector('#contact-email');
            const phoneInput = document.querySelector('#contact-phone');
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            
            if (emailInput && emailRegex.test(emailInput.value)) {
                // Save email and phone
                formData.email = emailInput.value;
                formData.phone = phoneInput.value.trim() || '';
                
                // Start image generation in background
                startBackgroundImageGeneration();
                
                // Show a subtle indicator that generation has started
                showGenerationStartedIndicator();
                
                nextQuestion();
            }
            // Removed alert popup - just don't advance if email is invalid
        }

        let backgroundImagePromise = null;

        async function startBackgroundImageGeneration() {
            try {
                console.log('Starting background image generation...');
                
                // Get API key from config or prompt for it
                let apiKey = window.CONFIG?.OPENAI_API_KEY || window.OPENAI_API_KEY;
                if (!apiKey) {
                    apiKey = prompt('Please enter your OpenAI API key to generate the charm image:');
                    if (!apiKey) {
                        console.log('No API key provided, skipping background generation');
                        return;
                    }
                    window.OPENAI_API_KEY = apiKey;
                }
                
                const responses = captureAllResponses();
                const promptData = generatePromptFromResponses(responses);
                
                // Check if we have uploaded images to incorporate
                const hasUploadedImages = responses.uploaded_images.Q2_images.length > 0 || 
                                        responses.uploaded_images.Q7_images.length > 0 || 
                                        responses.uploaded_images.Q9_images.length > 0;
                
                let promptText;
                let inputContent = [];
                
                if (hasUploadedImages) {
                    // Create prompt that incorporates the uploaded images
                    if (responses.uploaded_images.Q2_images.length > 0) {
                        // Path C: Exact design - make this image into a charm
                        promptText = `Transform this image into a single ${promptData.material} charm with a jump ring. Create two distinct design variations with dimensional, sculptural 2.5D relief: 

DESIGN 1 - Simple Realistic Style: Recreate the main subjects and elements from the image as a raised, dimensional relief design with varying depths and levels. Use realistic proportions and forms with clear depth gradations - foreground elements should be higher relief, background elements in lower relief. Create a sculptural, coin-like appearance with smooth transitions between different height levels. Focus on clear, recognizable 3D forms that capture the essence of the photo.

DESIGN 2 - Simple Cartoonish Style: Transform the subjects from the image into a cute, stylized cartoon version with pronounced 2.5D sculptural relief. Use simplified shapes with exaggerated dimensional features - rounded, puffy forms that pop out from the surface. Create playful depth with cartoon-like bulges, curves, and raised elements. Make it dimensionally charming with clear height variations between different parts of the design.

Both designs must have significant dimensional depth and sculptural relief - NOT flat engravings. Create medal-like, coin-like dimensional quality with varying heights across the surface. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                        
                        // Add the uploaded image(s) to input
                        inputContent.push({
                            "type": "input_text",
                            "text": promptText
                        });
                        
                        responses.uploaded_images.Q2_images.forEach(imageBase64 => {
                            inputContent.push({
                                "type": "input_image",
                                "image_url": imageBase64
                            });
                        });
            } else {
                        // Path A or B: Combine text preferences with image inspiration
                        // Build detailed user preferences from survey responses
                        let detailedPreferences = `
USER SURVEY RESPONSES TO INCORPORATE:
- Material: ${promptData.material}
- Style: ${promptData.style}
- Subject/Theme: ${promptData.subject}`;

                        if (responses.inspiration) {
                            detailedPreferences += `\n- Story/Inspiration: ${responses.inspiration}`;
                        }
                        if (responses.symbols) {
                            detailedPreferences += `\n- Requested Symbols/Elements: ${responses.symbols}`;
                        }
                        if (responses.style_vibes && responses.style_vibes.length > 0) {
                            detailedPreferences += `\n- Style Vibes: ${responses.style_vibes.join(', ')}`;
                        }
                        if (responses.size_presence) {
                            detailedPreferences += `\n- Size Preference: ${responses.size_presence}`;
                        }
                        if (responses.special_details) {
                            detailedPreferences += `\n- Special Details: ${responses.special_details}`;
                        }

                        promptText = `Create a single ${promptData.subject} charm with a jump ring, combining the user's specific survey responses with inspiration from the reference image(s). Generate 2 distinct style variations with full 3D sculptural relief:

${detailedPreferences}

DESIGN 1 - Simple Style: Create a clean, elegant interpretation that blends the reference images with ALL the user's survey responses above. Use sophisticated, refined forms with smooth sculptural relief and varying depths. Incorporate the requested symbols, story elements, and style preferences while drawing inspiration from the reference images. Full 3D dimensional quality with subtle height variations.

DESIGN 2 - Cartoonish/Cute Style: Transform the same concept into a playful, adorable version with exaggerated cute features. Use rounded, puffy forms that pop out dramatically from the surface. Make it whimsical and charming with pronounced 3D sculptural elements, cartoon-like proportions, and endearing details. Incorporate ALL the user's survey responses (symbols, story, style vibes) while being inspired by the reference images.

Both designs must incorporate ALL the user's stated survey responses while drawing visual inspiration from the reference images. Create full 3D sculptural relief with significant dimensional depth - NOT flat designs. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                        
                        inputContent.push({
                            "type": "input_text", 
                            "text": promptText
                        });
                        
                        // Add inspiration/reference images
                        const allImages = [...responses.uploaded_images.Q7_images, ...responses.uploaded_images.Q9_images];
                        allImages.forEach(imageBase64 => {
                            inputContent.push({
                                "type": "input_image",
                                "image_url": imageBase64
                            });
                        });
                    }
                } else {
                    // No uploaded images - use text-only prompt
                    promptText = `Create a single ${promptData.subject} with ${promptData.style} styling. Material: ${promptData.material}. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.detail}. ${promptData.camera}. Generate 2 different design variations.`;
                    inputContent.push({
                        "type": "input_text",
                        "text": promptText
                    });
                }
                
                console.log('Background generation prompt:', promptText);
                
                // Make separate API calls for each design to ensure we get 2 images
                const design1Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 1 only');
                const design2Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 2 only');
                
                const promises = [];
                
                // Generate Design 1
                promises.push(fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify({
                        model: "gpt-4.1-mini",
                        input: hasUploadedImages ? [{
                            "role": "user",
                            "content": [
                                {
                                    "type": "input_text",
                                    "text": design1Prompt
                                },
                                ...inputContent.filter(item => item.type === "input_image")
                            ]
                        }] : design1Prompt,
                        tools: [{
                            type: "image_generation",
                            quality: "high",
                            size: "1024x1024",
                            background: "opaque"
                        }]
                    })
                }).then(response => response.json()));
                
                // Generate Design 2
                promises.push(fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify({
                        model: "gpt-4.1-mini",
                        input: hasUploadedImages ? [{
                            "role": "user",
                            "content": [
                                {
                                    "type": "input_text",
                                    "text": design2Prompt
                                },
                                ...inputContent.filter(item => item.type === "input_image")
                            ]
                        }] : design2Prompt,
                        tools: [{
                            type: "image_generation",
                            quality: "high",
                            size: "1024x1024",
                            background: "opaque"
                        }]
                    })
                }).then(response => response.json()));
                
                backgroundImagePromise = Promise.all(promises).then(results => {
                    // Combine results into expected format
                    const combinedData = {
                        output: []
                    };
                    
                    results.forEach(result => {
                        if (result.output) {
                            combinedData.output.push(...result.output.filter(output => output.type === "image_generation_call"));
                        }
                    });
                    
                    return combinedData;
                });
                
                console.log('Background image generation started');
                
            } catch (error) {
                console.error('Error starting background image generation:', error);
                backgroundImagePromise = null;
            }
        }

        function showGenerationStartedIndicator() {
            // Add a subtle indicator to the page that generation has started
            const indicator = document.createElement('div');
            indicator.id = 'generation-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #DAE0FF;
                color: #000;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                z-index: 1000;
                border: 1px solid #000;
                animation: fadeInOut 3s ease-in-out;
            `;
            indicator.textContent = ':) Generating your charm design...';
            
            // Add fade animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateY(-10px); }
                    20% { opacity: 1; transform: translateY(0); }
                    80% { opacity: 1; transform: translateY(0); }
                    100% { opacity: 0; transform: translateY(-10px); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(indicator);
            
            // Remove after animation
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 3000);
        }



        function submitForm() {
            // Save final answer
            formData.community = document.querySelector('.question-container.active .option.selected').textContent.trim();
            
            // Generate results summary
            generateResults();
            nextQuestion();
        }

        function generateResults() {
            const resultsList = document.getElementById('resultsList');
            const displayData = {
                'Journey Type': formData.Q1 === 'A' ? 'Exploratory Design' : formData.Q1 === 'B' ? 'Idea Refinement' : 'Direct Creation',
                'Email': formData.email || 'Not provided',
                'Phone': formData.phone || 'Not provided',
                'Material': getOptionText(formData.Q12),
                'Style': getOptionText(formData.Q11),
                'Community Share': formData.community || 'Not specified'
            };
            
            // Add vibe if selected
            if (formData.Q5 || formData.Q10) {
                const vibes = formData.Q5 || formData.Q10;
                if (vibes && vibes.length > 0) {
                    displayData['Vibe'] = vibes.map(v => getVibeText(v)).join(', ');
                }
            }
            
            resultsList.innerHTML = '';
            for (const [key, value] of Object.entries(displayData)) {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${key}:</strong> ${value}`;
                resultsList.appendChild(li);
            }
            
            // Generate and display the charm image
            generateCharmImage();
            
            // Debug: Show captured responses and generated prompt
            console.log('All captured responses:', captureAllResponses());
            console.log('Generated prompt data:', generatePromptFromResponses(captureAllResponses()));
        }

        function captureAllResponses() {
            const responses = {
                journey_type: formData.Q1,
                inspiration: formData.Q3 || formData.Q8,
                recipient: formData.Q4,
                style_vibes: formData.Q5 || formData.Q10 || [],
                symbols: formData.Q6,
                size_presence: formData.Q11,
                material: formData.Q12,
                special_details: formData.Q13,
                email: formData.email,
                phone: formData.phone,
                community_share: formData.community,
                // Include uploaded images
                uploaded_images: {
                    Q2_images: formData.Q2_base64 || [], // Path C: exact design images
                    Q7_images: formData.Q7_base64 || [], // Path A: inspiration images
                    Q9_images: formData.Q9_base64 || []  // Path B: reference images
                }
            };
            return responses;
        }

        function generatePromptFromResponses(responses) {
            // Determine object description based on responses
            let objectDescription = 'elegant charm';
            
            if (responses.symbols) {
                objectDescription = responses.symbols.toLowerCase();
            } else if (responses.inspiration) {
                if (responses.inspiration.includes('moment')) objectDescription = 'commemorative medallion';
                else if (responses.inspiration.includes('person')) objectDescription = 'heart-shaped pendant';
                else if (responses.inspiration.includes('place')) objectDescription = 'compass or map-inspired charm';
                else if (responses.inspiration.includes('curious')) objectDescription = 'geometric charm';
            }
            
            // Determine material based on selection
            let materialType = 'polished reflective gold metal';
            if (responses.material === 'sterling-silver') {
                materialType = 'polished reflective silver metal';
            } else if (responses.material === 'gold-plated') {
                materialType = 'gold-plated silver with warm reflective finish';
            }
            
            // Adjust style based on size preference
            let styleAdjustment = 'high-gloss 3D sculptural metal';
            if (responses.size_presence === 'subtle') {
                styleAdjustment = 'delicate high-gloss 3D sculptural metal with fine details';
            } else if (responses.size_presence === 'bold-sculptural') {
                styleAdjustment = 'bold high-gloss 3D sculptural metal with dramatic presence';
            }
            
            // Incorporate style vibes
            let vibeAdjustment = '';
            if (responses.style_vibes && responses.style_vibes.length > 0) {
                if (responses.style_vibes.includes('elegant')) vibeAdjustment += ', elegant and refined';
                if (responses.style_vibes.includes('bold')) vibeAdjustment += ', bold and confident';
                if (responses.style_vibes.includes('playful')) vibeAdjustment += ', playful and whimsical';
                if (responses.style_vibes.includes('spiritual')) vibeAdjustment += ', meaningful and symbolic';
                if (responses.style_vibes.includes('sweet')) vibeAdjustment += ', sweet and sentimental';
            }

            const prompt = {
                "subject": `a single ${materialType.includes('gold') ? 'gold' : 'silver'} charm in the shape of ${objectDescription}${vibeAdjustment}`,
                "style": styleAdjustment,
                "material": materialType,
                "lighting": "studio lighting with soft reflections and minimal shadows",
                "background": "clean off-white or cream gradient",
                "presentation": "floating product shot, single charm with jump ring attached, angled to show volume and shine",
                "detail": "smooth, rounded surfaces with subtle contours, includes a jump ring for attachment, no engraving or texture",
                "camera": "close-up, eye-level with a slight tilt"
            };
            
            return prompt;
        }

        async function generateCharmImage() {
            try {
                const responses = captureAllResponses();
                const promptData = generatePromptFromResponses(responses);
                
                // Check if we have uploaded images to incorporate
                const hasUploadedImages = responses.uploaded_images.Q2_images.length > 0 || 
                                        responses.uploaded_images.Q7_images.length > 0 || 
                                        responses.uploaded_images.Q9_images.length > 0;
                
                let promptText;
                if (hasUploadedImages) {
                    if (responses.uploaded_images.Q2_images.length > 0) {
                        promptText = `Transform this image into a single ${promptData.material} charm with a jump ring. Create two distinct design variations with dimensional, sculptural 2.5D relief: 

DESIGN 1 - Simple Realistic Style: Recreate the main subjects and elements from the image as a raised, dimensional relief design with varying depths and levels. Use realistic proportions and forms with clear depth gradations - foreground elements should be higher relief, background elements in lower relief. Create a sculptural, coin-like appearance with smooth transitions between different height levels. Focus on clear, recognizable 3D forms that capture the essence of the photo.

DESIGN 2 - Simple Cartoonish Style: Transform the subjects from the image into a cute, stylized cartoon version with pronounced 2.5D sculptural relief. Use simplified shapes with exaggerated dimensional features - rounded, puffy forms that pop out from the surface. Create playful depth with cartoon-like bulges, curves, and raised elements. Make it dimensionally charming with clear height variations between different parts of the design.

Both designs must have significant dimensional depth and sculptural relief - NOT flat engravings. Create medal-like, coin-like dimensional quality with varying heights across the surface. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                    } else {
                        // Build detailed user preferences from survey responses
                        let detailedPreferences = `
USER SURVEY RESPONSES TO INCORPORATE:
- Material: ${promptData.material}
- Style: ${promptData.style}
- Subject/Theme: ${promptData.subject}`;

                        if (responses.inspiration) {
                            detailedPreferences += `\n- Story/Inspiration: ${responses.inspiration}`;
                        }
                        if (responses.symbols) {
                            detailedPreferences += `\n- Requested Symbols/Elements: ${responses.symbols}`;
                        }
                        if (responses.style_vibes && responses.style_vibes.length > 0) {
                            detailedPreferences += `\n- Style Vibes: ${responses.style_vibes.join(', ')}`;
                        }
                        if (responses.size_presence) {
                            detailedPreferences += `\n- Size Preference: ${responses.size_presence}`;
                        }
                        if (responses.special_details) {
                            detailedPreferences += `\n- Special Details: ${responses.special_details}`;
                        }

                        promptText = `Create a single ${promptData.subject} charm with a jump ring, combining the user's specific survey responses with inspiration from the reference image(s). Generate 2 distinct style variations with full 3D sculptural relief:

${detailedPreferences}

DESIGN 1 - Simple Style: Create a clean, elegant interpretation that blends the reference images with ALL the user's survey responses above. Use sophisticated, refined forms with smooth sculptural relief and varying depths. Incorporate the requested symbols, story elements, and style preferences while drawing inspiration from the reference images. Full 3D dimensional quality with subtle height variations.

DESIGN 2 - Cartoonish/Cute Style: Transform the same concept into a playful, adorable version with exaggerated cute features. Use rounded, puffy forms that pop out dramatically from the surface. Make it whimsical and charming with pronounced 3D sculptural elements, cartoon-like proportions, and endearing details. Incorporate ALL the user's survey responses (symbols, story, style vibes) while being inspired by the reference images.

Both designs must incorporate ALL the user's stated survey responses while drawing visual inspiration from the reference images. Create full 3D sculptural relief with significant dimensional depth - NOT flat designs. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                    }
                } else {
                    promptText = `Create a single ${promptData.subject} with ${promptData.style} styling. Material: ${promptData.material}. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.detail}. ${promptData.camera}. Generate 2 different design variations.`;
                }
                
                console.log('Generated prompt:', promptText);
                console.log('Has uploaded images:', hasUploadedImages);
                
                // Add loading indicator
                const resultsDiv = document.querySelector('.results');
                const loadingDiv = document.createElement('div');
                
                // Check if background generation is available
                if (backgroundImagePromise) {
                    loadingDiv.innerHTML = '<p style="text-align: center; margin: 20px 0;"><em>Finalizing your custom charm design...</em></p>';
                    console.log('Using background-generated image');
                } else {
                    loadingDiv.innerHTML = '<p style="text-align: center; margin: 20px 0;"><em>Generating your custom charm design...</em></p>';
                    console.log('Starting fresh image generation');
                }
                
                loadingDiv.id = 'image-loading';
                resultsDiv.appendChild(loadingDiv);
                
                let data;
                
                // Try to use background-generated image first
                if (backgroundImagePromise) {
                    try {
                        data = await backgroundImagePromise;
                        console.log('Background image ready!');
                    } catch (error) {
                        console.log('Background generation failed, starting fresh:', error);
                        backgroundImagePromise = null;
                    }
                }
                
                // If no background image available, generate fresh
                if (!backgroundImagePromise) {
                    // Get API key from config or prompt for it
                    let apiKey = window.CONFIG?.OPENAI_API_KEY || window.OPENAI_API_KEY;
                    if (!apiKey) {
                        apiKey = prompt('Please enter your OpenAI API key to generate the charm image:');
                        if (!apiKey) {
                            throw new Error('API key required for image generation');
                        }
                        window.OPENAI_API_KEY = apiKey;
                    }
                    
                    let inputContent = [];
                    
                    if (hasUploadedImages) {
                        inputContent.push({
                            "type": "input_text",
                            "text": promptText
                        });
                        
                        if (responses.uploaded_images.Q2_images.length > 0) {
                            responses.uploaded_images.Q2_images.forEach(imageBase64 => {
                                inputContent.push({
                                    "type": "input_image",
                                    "image_url": imageBase64
                                });
                            });
                        } else {
                            const allImages = [...responses.uploaded_images.Q7_images, ...responses.uploaded_images.Q9_images];
                            allImages.forEach(imageBase64 => {
                                inputContent.push({
                                    "type": "input_image",
                                    "image_url": imageBase64
                                });
                            });
                        }
                    } else {
                        inputContent.push({
                            "type": "input_text",
                            "text": promptText
                        });
                    }
                    
                    // Make separate API calls for each design to ensure we get 2 images
                    const design1Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 1 only');
                    const design2Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 2 only');
                    
                    const promises = [];
                    
                    // Generate Design 1
                    promises.push(fetch('https://api.openai.com/v1/responses', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + apiKey
                        },
                        body: JSON.stringify({
                            model: "gpt-4.1-mini",
                            input: hasUploadedImages ? [{
                                "role": "user",
                                "content": [
                                    {
                                        "type": "input_text",
                                        "text": design1Prompt
                                    },
                                    ...inputContent.filter(item => item.type === "input_image")
                                ]
                            }] : design1Prompt,
                            tools: [{
                                type: "image_generation",
                                quality: "high",
                                size: "1024x1024",
                                background: "opaque"
                            }]
                        })
                    }).then(response => response.json()));
                    
                    // Generate Design 2
                    promises.push(fetch('https://api.openai.com/v1/responses', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + apiKey
                        },
                        body: JSON.stringify({
                            model: "gpt-4.1-mini",
                            input: hasUploadedImages ? [{
                                "role": "user",
                                "content": [
                                    {
                                        "type": "input_text",
                                        "text": design2Prompt
                                    },
                                    ...inputContent.filter(item => item.type === "input_image")
                                ]
                            }] : design2Prompt,
                            tools: [{
                                type: "image_generation",
                                quality: "high",
                                size: "1024x1024",
                                background: "opaque"
                            }]
                        })
                    }).then(response => response.json()));
                    
                    const results = await Promise.all(promises);
                    
                    // Combine results into expected format
                    data = {
                        output: []
                    };
                    
                    results.forEach(result => {
                        if (result.output) {
                            data.output.push(...result.output.filter(output => output.type === "image_generation_call"));
                        }
                    });
                }
                
                // Remove loading indicator
                const loading = document.getElementById('image-loading');
                if (loading) loading.remove();
                
                // Extract image data from response
                const imageGenerationCalls = data.output?.filter(output => output.type === "image_generation_call") || [];
                
                if (imageGenerationCalls.length > 0) {
                    const imageTypeText = hasUploadedImages ? 
                        (responses.uploaded_images.Q2_images.length > 0 ? 
                            'Based on your uploaded design' : 
                            'Inspired by your reference images') : 
                        'Generated from your preferences';
                    
                    const generationMethod = backgroundImagePromise ? 
                        'Pre-generated while you completed the questionnaire' : 
                        'Generated fresh for your design';
                    
                    // Display header
                    const headerDiv = document.createElement('div');
                    headerDiv.innerHTML = `
                        <h4 style="margin: 20px 0 10px 0; color: #000;">Your Design Picks:</h4>
                        <p style="font-size: 14px; color: #666; margin-bottom: 15px;"><strong>${imageTypeText}</strong></p>
                    `;
                    resultsDiv.appendChild(headerDiv);
                    
                    // Create container for side-by-side layout
                    const imagesContainer = document.createElement('div');
                    imagesContainer.style.cssText = 'display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;';
                    
                    // Display each generated image
                    imageGenerationCalls.forEach((call, index) => {
                        if (call.result) {
                            // Convert base64 to blob URL for display
                            const base64Data = call.result;
                            const byteCharacters = atob(base64Data);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: 'image/png' });
                            const imageUrl = URL.createObjectURL(blob);
                            
                            const imageDiv = document.createElement('div');
                            imageDiv.style.cssText = 'flex: 1; min-width: 250px; padding: 15px; border: 1px solid #eee; border-radius: 8px; text-align: center;';
                            
                            // Determine design type based on path and index
                            let designType;
                            if (responses.uploaded_images.Q2_images.length > 0) {
                                // Path C: Exact picture - realistic vs cartoonish of the exact image
                                designType = index === 0 ? 'Simple Realistic' : 'Simple Cartoonish';
                            } else {
                                // Path A/B: Image+text combination - simple vs cute interpretations
                                designType = index === 0 ? 'Simple Style' : 'Cartoonish/Cute Style';
                            }
                            imageDiv.innerHTML = `
                                <h5 style="margin: 0 0 10px 0; color: #000;">Design ${index + 1}: ${designType}</h5>
                                
                                <div class="design-carousel" id="carousel-${index + 1}" style="position: relative; margin-bottom: 15px;">
                                    <div class="carousel-container" style="overflow: hidden; border: 1px solid #ddd; border-radius: 8px;">
                                        <div class="carousel-track" id="track-${index + 1}" style="display: flex; transition: transform 0.3s ease;">
                                            <img src="${imageUrl}" alt="Generated charm design ${index + 1}" style="min-width: 100%; height: auto; display: block;" data-version="1">
                                        </div>
                                    </div>
                                    
                                    <div class="carousel-controls" style="display: none; justify-content: space-between; align-items: center; margin-top: 8px;">
                                        <button onclick="previousDesign(${index + 1})" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #666; padding: 5px;" title="Previous design">‹</button>
                                        <span class="carousel-indicator" id="indicator-${index + 1}" style="font-size: 12px; color: #666; font-weight: 300;">1 of 1</span>
                                        <button onclick="nextDesign(${index + 1})" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #666; padding: 5px;" title="Next design">›</button>
                                    </div>
                                </div>
                                
                                <div class="feedback-section" style="margin-top: 20px; padding: 20px; background: #ffffff; border: 1px solid #e0e0e0; border-radius: 0px; opacity: 0.85;">
                                    <p style="margin: 0 0 15px 0; color: #666; font-size: 14px; font-weight: 300; text-align: center;">Want to refine this design?</p>
                                    <textarea 
                                        id="feedback-${index + 1}" 
                                        placeholder="Share your thoughts... (e.g., make it more delicate, add sparkle, change proportions)"
                                        style="width: 100%; height: 70px; padding: 15px; border: 1px solid #000000; font-size: 14px; font-family: inherit; font-weight: 300; resize: vertical; margin-bottom: 15px; background: #ffffff; transition: all 0.3s ease;"
                                        onfocus="this.style.background='#DAE0FF'; this.style.borderColor='#000000';"
                                        onblur="this.style.background='#ffffff'; this.style.borderColor='#000000';"
                                    ></textarea>
                                    <button 
                                        onclick="regenerateDesign(${index + 1})" 
                                        style="width: 100%; padding: 12px 20px; background: #f8f8f8; color: #333333; border: 1px solid #dddddd; font-size: 14px; font-weight: 400; cursor: pointer; transition: all 0.3s ease; font-family: inherit; letter-spacing: 0.5px;"
                                        onmouseover="this.style.background='#DAE0FF'; this.style.color='#000000'; this.style.borderColor='#000000';"
                                        onmouseout="this.style.background='#f8f8f8'; this.style.color='#333333'; this.style.borderColor='#dddddd';"
                                    >
                                        :D Refine Design ${index + 1}
                                    </button>
                                </div>
                            `;
                            imagesContainer.appendChild(imageDiv);
                        }
                    });
                    
                    resultsDiv.appendChild(imagesContainer);
                    
                    // Add footer info
                    const footerDiv = document.createElement('div');
                    footerDiv.innerHTML = `
                        <p style="font-size: 14px; color: #666; margin: 15px 0 10px 0;"><strong>Prompt used:</strong> ${promptText}</p>
                        <p style="font-size: 12px; color: #999;">Generated using GPT Image 1 (latest model)</p>
                        <p style="font-size: 11px; color: #aaa; margin-top: 5px;">${generationMethod}</p>
                    `;
                    resultsDiv.appendChild(footerDiv);
                } else {
                    throw new Error('No images generated');
                }
                
            } catch (error) {
                console.error('Error generating image:', error);
                
                // Remove loading indicator
                const loading = document.getElementById('image-loading');
                if (loading) loading.remove();
                
                // Show error message
                const resultsDiv = document.querySelector('.results');
                const errorDiv = document.createElement('div');
                errorDiv.innerHTML = `
                    <p style="color: #666; text-align: center; margin: 20px 0;">
                        <em>Image generation temporarily unavailable. We'll still create your custom design manually!</em>
                    </p>
                `;
                resultsDiv.appendChild(errorDiv);
            }
        }

        function getOptionText(value) {
            const mapping = {
                'subtle': 'Subtle & delicate',
                'bold-sculptural': 'Bold & sculptural',
                'classic': 'Classic & balanced',
                'not-sure': 'Not sure yet',
                '14k-gold': '14K Solid Gold',
                'sterling-silver': 'Sterling Silver (925)',
                'gold-plated': 'Gold-Plated Silver',
                'help-decide': 'Help me decide'
            };
            return mapping[value] || value;
        }

        function getVibeText(value) {
            const mapping = {
                'elegant': 'Elegant & Timeless',
                'bold': 'Bold & Confident',
                'playful': 'Playful & Cute',
                'spiritual': 'Spiritual & Symbolic',
                'sweet': 'Sweet & Sentimental'
            };
            return mapping[value] || value;
        }

        // Carousel navigation functions
        function previousDesign(designNumber) {
            const track = document.getElementById(`track-${designNumber}`);
            const images = track.querySelectorAll('img');
            const currentIndex = parseInt(track.dataset.currentIndex || '0');
            
            if (currentIndex > 0) {
                const newIndex = currentIndex - 1;
                track.style.transform = `translateX(-${newIndex * 100}%)`;
                track.dataset.currentIndex = newIndex;
                updateCarouselIndicator(designNumber, newIndex + 1, images.length);
            }
        }

        function nextDesign(designNumber) {
            const track = document.getElementById(`track-${designNumber}`);
            const images = track.querySelectorAll('img');
            const currentIndex = parseInt(track.dataset.currentIndex || '0');
            
            if (currentIndex < images.length - 1) {
                const newIndex = currentIndex + 1;
                track.style.transform = `translateX(-${newIndex * 100}%)`;
                track.dataset.currentIndex = newIndex;
                updateCarouselIndicator(designNumber, newIndex + 1, images.length);
            }
        }

        function updateCarouselIndicator(designNumber, current, total) {
            const indicator = document.getElementById(`indicator-${designNumber}`);
            indicator.textContent = `${current} of ${total}`;
            
            // Show/hide controls based on whether there are multiple images
            const controls = indicator.parentElement;
            if (total > 1) {
                controls.style.display = 'flex';
            } else {
                controls.style.display = 'none';
            }
        }

        async function regenerateDesign(designNumber) {
            try {
                const feedbackTextarea = document.getElementById(`feedback-${designNumber}`);
                const feedback = feedbackTextarea.value.trim();
                
                if (!feedback) {
                    alert('Please provide feedback about what you\'d like to change in this design.');
                    return;
                }
                
                // Get API key
                let apiKey = window.CONFIG?.OPENAI_API_KEY || window.OPENAI_API_KEY;
                if (!apiKey) {
                    apiKey = prompt('Please enter your OpenAI API key to regenerate the design:');
                    if (!apiKey) {
                        throw new Error('API key required for regeneration');
                    }
                    window.OPENAI_API_KEY = apiKey;
                }
                
                // Show loading state
                const button = feedbackTextarea.nextElementSibling;
                const originalText = button.textContent;
                button.textContent = 'Regenerating...';
                button.disabled = true;
                button.style.background = '#ccc';
                
                // Get current responses and prompt data
                const responses = captureAllResponses();
                const promptData = generatePromptFromResponses(responses);
                
                // Check if we have uploaded images
                const hasUploadedImages = responses.uploaded_images.Q2_images.length > 0 || 
                                        responses.uploaded_images.Q7_images.length > 0 || 
                                        responses.uploaded_images.Q9_images.length > 0;
                
                // Build the regeneration prompt based on the design number and feedback
                let regenerationPrompt;
                const designType = designNumber === 1 ? 'Simple Style' : 'Cartoonish/Cute Style';
                
                if (hasUploadedImages) {
                    if (responses.uploaded_images.Q2_images.length > 0) {
                        // Path C: Exact picture
                        regenerationPrompt = `Transform this image into a single ${promptData.material} charm with a jump ring. Create a ${designType} design with dimensional, sculptural 2.5D relief.

ORIGINAL DESIGN TYPE: ${designType === 'Simple Style' ? 'Simple Realistic Style - raised, dimensional relief design with varying depths and realistic proportions' : 'Simple Cartoonish Style - cute, stylized cartoon version with pronounced 2.5D sculptural relief'}

USER FEEDBACK TO INCORPORATE: ${feedback}

Based on the feedback above, modify the ${designType} approach while maintaining the core design principles. Address the user's specific requests while keeping the dimensional, sculptural quality. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                    } else {
                        // Path A/B: Image + text combination
                        let detailedPreferences = `
USER SURVEY RESPONSES TO INCORPORATE:
- Material: ${promptData.material}
- Style: ${promptData.style}
- Subject/Theme: ${promptData.subject}`;

                        if (responses.inspiration) detailedPreferences += `\n- Story/Inspiration: ${responses.inspiration}`;
                        if (responses.symbols) detailedPreferences += `\n- Requested Symbols/Elements: ${responses.symbols}`;
                        if (responses.style_vibes && responses.style_vibes.length > 0) detailedPreferences += `\n- Style Vibes: ${responses.style_vibes.join(', ')}`;
                        if (responses.size_presence) detailedPreferences += `\n- Size Preference: ${responses.size_presence}`;
                        if (responses.special_details) detailedPreferences += `\n- Special Details: ${responses.special_details}`;

                        regenerationPrompt = `Create a single ${promptData.subject} charm with a jump ring, combining the user's survey responses with inspiration from the reference image(s). Generate a ${designType} design with full 3D sculptural relief:

${detailedPreferences}

ORIGINAL DESIGN TYPE: ${designType} - ${designType === 'Simple Style' ? 'clean, elegant interpretation with sophisticated, refined forms' : 'playful, adorable version with exaggerated cute features and cartoon-like proportions'}

USER FEEDBACK TO INCORPORATE: ${feedback}

Based on the feedback above, create an improved ${designType} design that addresses the user's specific requests while incorporating ALL survey responses and drawing inspiration from the reference images. Maintain full 3D sculptural relief with significant dimensional depth. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                    }
                } else {
                    // Text-only path
                    regenerationPrompt = `Create a single ${promptData.subject} with ${promptData.style} styling. Material: ${promptData.material}.

ORIGINAL DESIGN TYPE: ${designType}

USER FEEDBACK TO INCORPORATE: ${feedback}

Based on the feedback above, create an improved ${designType} design that addresses the user's specific requests. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.detail}. ${promptData.camera}.`;
                }
                
                // Prepare input content
                let inputContent = [];
                if (hasUploadedImages) {
                    inputContent.push({
                        "type": "input_text",
                        "text": regenerationPrompt
                    });
                    
                    // Add images
                    if (responses.uploaded_images.Q2_images.length > 0) {
                        responses.uploaded_images.Q2_images.forEach(imageBase64 => {
                            inputContent.push({
                                "type": "input_image",
                                "image_url": imageBase64
                            });
                        });
                    } else {
                        const allImages = [...responses.uploaded_images.Q7_images, ...responses.uploaded_images.Q9_images];
                        allImages.forEach(imageBase64 => {
                            inputContent.push({
                                "type": "input_image",
                                "image_url": imageBase64
                            });
                        });
                    }
                }
                
                // Make API call
                const response = await fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify({
                        model: "gpt-4.1-mini",
                        input: hasUploadedImages ? [{
                            "role": "user",
                            "content": inputContent
                        }] : regenerationPrompt,
                        tools: [{
                            type: "image_generation",
                            quality: "high",
                            size: "1024x1024",
                            background: "opaque"
                        }]
                    })
                });
                
                const data = await response.json();
                
                // Extract the new image
                const imageGenerationCalls = data.output?.filter(output => output.type === "image_generation_call") || [];
                
                if (imageGenerationCalls.length > 0 && imageGenerationCalls[0].result) {
                    // Convert base64 to blob URL
                    const base64Data = imageGenerationCalls[0].result;
                    const byteCharacters = atob(base64Data);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: 'image/png' });
                    const newImageUrl = URL.createObjectURL(blob);
                    
                                         // Add the new image to the carousel
                     const designContainer = button.closest('.feedback-section').parentElement;
                     const track = designContainer.querySelector(`#track-${designNumber}`);
                     const images = track.querySelectorAll('img');
                     const newVersion = images.length + 1;
                     
                     // Create new image element
                     const newImage = document.createElement('img');
                     newImage.src = newImageUrl;
                     newImage.alt = `Generated charm design ${designNumber} - Version ${newVersion}`;
                     newImage.style.cssText = 'min-width: 100%; height: auto; display: block;';
                     newImage.dataset.version = newVersion;
                     
                     // Add to carousel track
                     track.appendChild(newImage);
                     
                     // Navigate to the new image
                     const newIndex = images.length;
                     track.style.transform = `translateX(-${newIndex * 100}%)`;
                     track.dataset.currentIndex = newIndex;
                     
                     // Update indicator and show controls
                     updateCarouselIndicator(designNumber, newIndex + 1, newVersion);
                     
                     // Clear the feedback textarea
                     feedbackTextarea.value = '';
                     
                     // Show success message
                     const successMsg = document.createElement('div');
                     successMsg.style.cssText = 'background: #d4edda; color: #155724; padding: 8px; border-radius: 4px; margin-top: 10px; font-size: 12px; text-align: center;';
                     successMsg.textContent = `:) Design ${designNumber} refined successfully! (Version ${newVersion})`;
                     feedbackTextarea.parentElement.appendChild(successMsg);
                     
                     // Remove success message after 3 seconds
                     setTimeout(() => {
                         if (successMsg.parentElement) {
                             successMsg.parentElement.removeChild(successMsg);
                         }
                     }, 3000);
                    
                } else {
                    throw new Error('No image generated');
                }
                
            } catch (error) {
                console.error('Error regenerating design:', error);
                alert('Sorry, there was an error regenerating the design. Please try again.');
            } finally {
                // Reset button state
                const button = document.querySelector(`#feedback-${designNumber}`).nextElementSibling;
                button.textContent = `Regenerate Design ${designNumber}`;
                button.disabled = false;
                button.style.background = '#000';
            }
        }

        // Enable continue button and auto-advance for text inputs
        document.querySelectorAll('textarea, input[type="email"], input[type="tel"]').forEach(input => {
            input.addEventListener('input', function() {
                const continueBtn = this.closest('.question-container').querySelector('.btn-primary');
                if (continueBtn) {
                    continueBtn.disabled = this.value.trim() === '';
                }
                
                // Clear any existing timer
                clearTimeout(window.textInputTimer);
                
                // Auto-advance for required fields after user stops typing
                if (this.id === 'contact-email' && this.value.trim() !== '') {
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (emailRegex.test(this.value)) {
                        window.textInputTimer = setTimeout(() => {
                            validateContact();
                        }, 1500);
                    }
                } else if (this.closest('[data-question="Q8"]') && this.value.trim() !== '') {
                    // Auto-advance for Q8 (required text field)
                    window.textInputTimer = setTimeout(() => {
                        nextQuestion();
                    }, 2000);
                }
            });
            
            // Handle Enter key for immediate advancement
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    if (this.tagName === 'TEXTAREA') {
                        e.preventDefault();
                    }
                    const continueBtn = this.closest('.question-container').querySelector('.btn-primary');
                    if (continueBtn && !continueBtn.disabled) {
                        continueBtn.click();
                    }
                }
            });
        });



        // Fix image preview issue by ensuring the preview container is properly appended
        function showImagePreviews(files, fileInfo) {
            console.log('Showing image previews for', files.length, 'files');
            
            // Clear existing previews and containers
            const container = fileInfo.parentElement;
            const existingPreviews = container.querySelectorAll('.image-preview');
            const existingContainers = container.querySelectorAll('.image-preview-container');
            existingPreviews.forEach(preview => preview.remove());
            existingContainers.forEach(cont => cont.remove());
            
            if (files.length === 0) {
                console.log('No files to preview');
                return;
            }
            
            // Create a container for all previews
            const previewContainer = document.createElement('div');
            previewContainer.className = 'image-preview-container';
            previewContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; justify-content: center;';
            
            let loadedCount = 0;
            const totalFiles = files.filter(file => file.type.startsWith('image/')).length;
            
            files.forEach((file, index) => {
                if (file.type.startsWith('image/')) {
                    console.log('Processing image file:', file.name);
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        console.log('Image loaded:', file.name);
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'image-preview';
                        previewDiv.style.cssText = 'text-align: center; flex: 0 0 auto;';
                        previewDiv.innerHTML = `
                            <img src="${e.target.result}" alt="Preview" style="max-width: 120px; max-height: 120px; border: 2px solid #000; border-radius: 8px; object-fit: cover;">
                            <p style="font-size: 11px; color: #666; margin: 5px 0 0 0; max-width: 120px; word-break: break-word;">${file.name}</p>
                        `;
                        previewContainer.appendChild(previewDiv);
                        
                        loadedCount++;
                        // Only append the container after all images are loaded
                        if (loadedCount === totalFiles) {
                            console.log('All images loaded, appending preview container');
                            container.appendChild(previewContainer);
                        }
                    };
                    reader.onerror = function(error) {
                        console.error('Error reading file:', file.name, error);
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // If no image files, still append empty container
            if (totalFiles === 0) {
                container.appendChild(previewContainer);
            }
        }

        // Initialize
        showQuestion('Q1');
        addArrowToButtons();
        
        // Setup drag and drop after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                setupDragAndDrop();
                console.log('Drag and drop setup complete');
            }, 200);
        });
        
        // Also setup on page load as fallback
        window.addEventListener('load', function() {
            setTimeout(() => {
                setupDragAndDrop();
                console.log('Drag and drop setup complete (fallback)');
            }, 300);
        });
    </script>
</body>
</html>