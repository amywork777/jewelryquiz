<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Charm Design Questionnaire</title>
    <script src="config.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Avenir Next', 'Avenir', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 300;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border: 1px solid #000000;
            box-shadow: 0 0 0 1px #000000;
            max-width: 600px;
            width: 100%;
            padding: 40px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #f0f0f0;
        }

        .progress-fill {
            height: 100%;
            background: #000000;
            width: 0%;
            transition: width 0.5s ease;
        }

        .question-container {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .question-container.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #000000;
            margin-bottom: 10px;
            font-size: 28px;
            font-weight: 300;
            letter-spacing: -0.5px;
        }

        h2 {
            color: #000000;
            margin-bottom: 30px;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: -0.3px;
        }

        p {
            color: #000000;
            margin-bottom: 30px;
            font-size: 18px;
            line-height: 1.6;
            font-weight: 300;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .option {
            padding: 20px;
            border: 1px solid #000000;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            text-align: left;
            background: #ffffff;
            font-weight: 300;
            position: relative;
        }

        .option::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0;
            background: #DAE0FF;
            transition: width 0.3s ease;
            z-index: -1;
        }

        .option:hover::after {
            width: 100%;
        }

        .option:hover {
            transform: translateX(5px);
        }

        .option:hover {
            transform: translateX(5px);
        }

        .option.selected {
            background: #DAE0FF;
            border: 2px solid #000000;
            padding: 19px;
            animation: selectPulse 0.3s ease;
        }

        @keyframes selectPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .multi-select .option.selected {
            background: #000000;
            color: #ffffff;
            border: 1px solid #000000;
            padding: 20px;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"],
        textarea {
            width: 100%;
            padding: 15px;
            border: 1px solid #000000;
            font-size: 16px;
            transition: border-color 0.3s ease;
            font-family: inherit;
            background: #ffffff;
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        input[type="tel"]:focus,
        textarea:focus {
            outline: none;
            border: 2px solid #000000;
            padding: 14px;
            background: #DAE0FF;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }

        .file-upload input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-upload-label {
            display: block;
            padding: 15px;
            border: 2px dashed #000000;
            text-align: center;
            color: #000000;
            transition: all 0.3s ease;
            background: #ffffff;
        }

        .file-upload:hover .file-upload-label {
            background: #DAE0FF;
        }

        .file-info {
            margin-top: 10px;
            color: #000000;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 30px;
            justify-content: flex-end;
        }

        button {
            padding: 12px 20px;
            border: 1px solid #cccccc;
            font-size: 16px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 0 0 auto;
            background: #ffffff;
            color: #666666;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 44px;
            max-width: 60px;
        }

        button svg {
            width: 16px;
            height: 16px;
            transition: transform 0.3s ease;
        }

        button:hover svg {
            transform: translateX(3px);
        }

        .btn-secondary:hover svg {
            transform: translateX(-3px);
        }

        .btn-primary {
            background: #f8f8f8;
            color: #333333;
            border: 1px solid #dddddd;
        }

        .btn-primary:hover {
            background: #DAE0FF;
            color: #000000;
            border: 1px solid #000000;
        }

        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #f5f5f5;
            color: #cccccc;
            border: 1px solid #eeeeee;
        }

        .btn-secondary {
            background: #ffffff;
            color: #666666;
            border: 1px solid #dddddd;
        }

        .btn-secondary:hover {
            background: #f0f0f0;
            color: #333333;
            border: 1px solid #999999;
        }

        .skip-link {
            text-align: center;
            margin-top: 15px;
            color: #000000;
            font-size: 14px;
        }

        .skip-link a {
            color: #000000;
            text-decoration: underline;
        }

        .skip-link a:hover {
            background: #DAE0FF;
            text-decoration: none;
        }

        .results {
            background: #DAE0FF;
            padding: 30px;
            margin-top: 30px;
            border: 1px solid #000000;
        }

        .results h3 {
            color: #000000;
            margin-bottom: 20px;
        }

        .results-list {
            list-style: none;
        }

        .results-list li {
            padding: 10px 0;
            border-bottom: 1px solid #000000;
        }

        .results-list li:last-child {
            border-bottom: none;
        }

        .results-list strong {
            color: #000000;
            display: inline-block;
            min-width: 150px;
        }

        .completion-message {
            text-align: center;
            padding: 40px;
        }

        .completion-message h1 {
            color: #000000;
            margin-bottom: 20px;
        }

        .completion-message p {
            font-size: 20px;
            color: #000000;
        }

        @media (max-width: 600px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 24px;
            }

            h2 {
                font-size: 20px;
            }

            p {
                font-size: 16px;
            }

            .option {
                padding: 15px;
                font-size: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>

        <!-- Question 1 -->
        <div class="question-container active" data-question="Q1">
            <h2>Let's create your custom charm</h2>
            <p>How much do you already know about what you want?</p>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'A')">
                    I need help with ideas
                </div>
                <div class="option" onclick="selectOption(this, 'B')">
                    I have some ideas
                </div>
                <div class="option" onclick="selectOption(this, 'C')">
                    I know exactly what I want
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="handleQ1Branch()" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Path C: Q2 -->
        <div class="question-container" data-question="Q2">
            <h2>Perfect! Show me your inspiration</h2>
            <p>Upload any photo, sketch, or reference image</p>
            <div class="file-upload">
                <input type="file" id="q2-file" accept="image/*" onchange="handleFileUpload('q2-file')">
                <label for="q2-file" class="file-upload-label">
                    Drop your image here or click to browse
                </label>
                <div class="file-info" id="q2-file-info"></div>
            </div>
            <div class="skip-link">
                <a href="#" onclick="skipUpload(); return false;">I'll describe it instead</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                </button>
                <button class="btn-primary" onclick="nextQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Path A: Q3 -->
        <div class="question-container" data-question="Q3">
            <h2>What's the story behind your charm?</h2>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'curious')">
                    Just browsing for something beautiful
                </div>
                <div class="option" onclick="selectOption(this, 'moment')">
                    Celebrating a special moment
                </div>
                <div class="option" onclick="selectOption(this, 'person')">
                    Honoring someone special
                </div>
                <div class="option" onclick="selectOption(this, 'place')">
                    Remembering a meaningful place
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Path A: Q4 -->
        <div class="question-container" data-question="Q4">
            <h2>Who will wear this charm?</h2>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'for-me')">
                    It's for me
                </div>
                <div class="option" onclick="selectOption(this, 'for-someone')">
                    A gift for someone special
                </div>
                <div class="option" onclick="selectOption(this, 'not-sure')">
                    Still deciding
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Paths C & B: Q5 & Q10 (same content, different IDs) -->
        <div class="question-container" data-question="Q5">
            <h2>What style appeals to you?</h2>
            <p>Choose all that feel right (you can select multiple)</p>
            <div class="options multi-select">
                <div class="option" onclick="toggleMultiSelect(this, 'elegant')">
                    Elegant & Timeless
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'bold')">
                    Bold & Confident
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'playful')">
                    Playful & Fun
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'spiritual')">
                    Spiritual & Meaningful
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'sweet')">
                    Sweet & Sentimental
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Path A: Q6 -->
        <div class="question-container" data-question="Q6">
            <h2>What symbols or elements would you like?</h2>
            <textarea placeholder="For example: hearts, stars, initials, flowers, animals, geometric shapes..."></textarea>
            <div class="skip-link">
                <a href="#" onclick="skipTextInput(); return false;">Skip - I'll decide later</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">Continue</button>
            </div>
        </div>

        <!-- Path A: Q7 -->
        <div class="question-container" data-question="Q7">
            <h2>Do you have any inspiration photos? (optional)</h2>
            <div class="file-upload">
                <input type="file" id="q7-file" accept="image/*" onchange="handleFileUpload('q7-file')">
                <label for="q7-file" class="file-upload-label">
                    Click to upload or drag and drop
                </label>
                <div class="file-info" id="q7-file-info"></div>
            </div>
            <div class="skip-link">
                <a href="#" onclick="skipUpload(); return false;">Skip this step</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">Continue</button>
            </div>
        </div>

        <!-- Path B: Q8 -->
        <div class="question-container" data-question="Q8">
            <h2>Tell me about your idea</h2>
            <textarea placeholder="Describe what you're envisioning... the more details, the better!"></textarea>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Path B: Q9 -->
        <div class="question-container" data-question="Q9">
            <h2>Upload any reference images (optional).</h2>
            <div class="file-upload">
                <input type="file" id="q9-file" accept="image/*" multiple onchange="handleFileUpload('q9-file')">
                <label for="q9-file" class="file-upload-label">
                    Click to upload or drag and drop
                </label>
                <div class="file-info" id="q9-file-info"></div>
            </div>
            <div class="skip-link">
                <a href="#" onclick="skipUpload(); return false;">Skip this step</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">Continue</button>
            </div>
        </div>

        <!-- Path B: Q10 (duplicate of Q5) -->
        <div class="question-container" data-question="Q10">
            <h2>What style appeals to you?</h2>
            <p>Choose all that feel right (you can select multiple)</p>
            <div class="options multi-select">
                <div class="option" onclick="toggleMultiSelect(this, 'elegant')">
                    Elegant & Timeless
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'bold')">
                    Bold & Confident
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'playful')">
                    Playful & Cute
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'spiritual')">
                    Spiritual & Symbolic
                </div>
                <div class="option" onclick="toggleMultiSelect(this, 'sweet')">
                    Sweet & Sentimental
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Convergence: Q11 -->
        <div class="question-container" data-question="Q11">
            <h2>What size and presence do you prefer?</h2>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'subtle')">
                    Small & delicate
                </div>
                <div class="option" onclick="selectOption(this, 'bold-sculptural')">
                    Bold & statement-making
                </div>
                <div class="option" onclick="selectOption(this, 'classic')">
                    Medium & versatile
                </div>
                <div class="option" onclick="selectOption(this, 'not-sure')">
                    I'm not sure yet
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Q12 -->
        <div class="question-container" data-question="Q12">
            <h2>What material would you prefer?</h2>
            <p>Each option has different qualities and pricing</p>
            <div class="options">
                <div class="option" onclick="selectOption(this, '14k-gold')">
                    14K Solid Gold
                    <span style="display: block; font-size: 14px; margin-top: 5px; opacity: 0.7;">Luxurious & lasting</span>
                </div>
                <div class="option" onclick="selectOption(this, 'sterling-silver')">
                    Sterling Silver
                    <span style="display: block; font-size: 14px; margin-top: 5px; opacity: 0.7;">Classic & affordable</span>
                </div>
                <div class="option" onclick="selectOption(this, 'gold-plated')">
                    Gold-Plated Silver
                    <span style="display: block; font-size: 14px; margin-top: 5px; opacity: 0.7;">Golden look, silver price</span>
                </div>
                <div class="option" onclick="selectOption(this, 'help-decide')">
                    Help me choose
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()" disabled>Continue</button>
            </div>
        </div>

        <!-- Q13 -->
        <div class="question-container" data-question="Q13">
            <h2>Any special details or requests?</h2>
            <textarea placeholder="For example: specific dates, sizing preferences, engraving ideas, or any other notes..."></textarea>
            <div class="skip-link">
                <a href="#" onclick="skipTextInput(); return false;">No special requests</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">Continue</button>
            </div>
        </div>

        <!-- Q14 -->
        <div class="question-container" data-question="Q14">
            <h2>Amazing! Your custom design is taking shape</h2>
            <p>We'll create something beautiful based on everything you've shared</p>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="nextQuestion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Contact Info -->
        <div class="question-container" data-question="email">
            <h2>What's your email address?</h2>
            <p>We'll send your custom design mockup here</p>
            <input type="email" placeholder="your@email.com" required>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="validateEmail()" disabled>Continue</button>
            </div>
        </div>

        <div class="question-container" data-question="phone">
            <h2>Phone number for updates? (optional)</h2>
            <p>We can text you when your design is ready</p>
            <input type="tel" placeholder="+1 (555) 123-4567">
            <div class="skip-link">
                <a href="#" onclick="skipPhone(); return false;">Email only is fine</a>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="validatePhone()">Continue</button>
            </div>
        </div>

        <div class="question-container" data-question="community">
            <h2>Can we feature your design in our gallery?</h2>
            <p>We love showcasing beautiful custom pieces to inspire other customers</p>
            <div class="options">
                <div class="option" onclick="selectOption(this, 'yes')">
                    Yes, that sounds great!
                </div>
                <div class="option" onclick="selectOption(this, 'no')">
                    No, keep it private
                </div>
            </div>
            <div class="button-group">
                <button class="btn-secondary" onclick="previousQuestion()">Back</button>
                <button class="btn-primary" onclick="submitForm()" disabled>
                    Submit
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Completion -->
        <div class="question-container" data-question="complete">
            <div class="completion-message">
                <h1>You're all set!</h1>
                <p>We'll craft your custom design and send it within 24-48 hours</p>
                <p style="font-size: 16px; margin-top: 20px;">Keep an eye on your inbox - you're going to love what we create together</p>
                <div class="results">
                    <h3>Your Design Summary:</h3>
                    <ul class="results-list" id="resultsList">
                        <!-- Results will be populated here -->
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        const formData = {};
        let questionFlow = ['Q1'];
        const questionHistory = [];

        function updateProgress() {
            const totalQuestions = questionFlow.length;
            const progress = ((currentQuestionIndex + 1) / totalQuestions) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function addArrowToButtons() {
            // Replace all button text with just arrows
            document.querySelectorAll('.btn-primary').forEach(btn => {
                if (btn.textContent.includes('Submit') || btn.innerHTML.includes('20 6 9 17 4 12')) {
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>`;
                } else {
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>`;
                }
            });
            
            document.querySelectorAll('.btn-secondary').forEach(btn => {
                btn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>`;
            });
        }

        function showQuestion(questionId) {
            document.querySelectorAll('.question-container').forEach(container => {
                container.classList.remove('active');
            });
            
            const targetQuestion = document.querySelector(`[data-question="${questionId}"]`);
            if (targetQuestion) {
                targetQuestion.classList.add('active');
                // Add arrows to buttons in the active question
                setTimeout(addArrowToButtons, 10);
            }
            
            updateProgress();
        }

        function nextQuestion() {
            const currentQuestion = questionFlow[currentQuestionIndex];
            
            // Save text inputs
            const textarea = document.querySelector(`.question-container.active textarea`);
            const emailInput = document.querySelector(`.question-container.active input[type="email"]`);
            const phoneInput = document.querySelector(`.question-container.active input[type="tel"]`);
            
            if (textarea) {
                formData[currentQuestion] = textarea.value;
            }
            if (emailInput) {
                formData.email = emailInput.value;
            }
            if (phoneInput) {
                formData.phone = phoneInput.value;
            }
            
            questionHistory.push(currentQuestionIndex);
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questionFlow.length) {
                showQuestion(questionFlow[currentQuestionIndex]);
            }
        }

        function previousQuestion() {
            if (questionHistory.length > 0) {
                currentQuestionIndex = questionHistory.pop();
                showQuestion(questionFlow[currentQuestionIndex]);
            }
        }

        function selectOption(element, value) {
            const container = element.parentElement;
            container.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            
            const questionId = element.closest('.question-container').dataset.question;
            formData[questionId] = value;
            
            // Enable continue button
            const continueBtn = element.closest('.question-container').querySelector('.btn-primary');
            if (continueBtn) {
                continueBtn.disabled = false;
            }
            
            // Auto-advance after a short delay
            setTimeout(() => {
                if (questionId === 'Q1') {
                    handleQ1Branch();
                } else if (questionId === 'community') {
                    submitForm();
                } else {
                    nextQuestion();
                }
            }, 300);
        }

        function toggleMultiSelect(element, value) {
            element.classList.toggle('selected');
            
            const questionId = element.closest('.question-container').dataset.question;
            if (!formData[questionId]) {
                formData[questionId] = [];
            }
            
            if (element.classList.contains('selected')) {
                formData[questionId].push(value);
            } else {
                formData[questionId] = formData[questionId].filter(v => v !== value);
            }
            
            // Enable continue button if at least one option is selected
            const continueBtn = element.closest('.question-container').querySelector('.btn-primary');
            if (continueBtn) {
                continueBtn.disabled = formData[questionId].length === 0;
            }
            
            // Auto-advance after selecting at least one option and a delay
            if (formData[questionId].length > 0) {
                clearTimeout(window.multiSelectTimer);
                window.multiSelectTimer = setTimeout(() => {
                    nextQuestion();
                }, 1000); // Slightly longer delay for multi-select
            }
        }

        function handleQ1Branch() {
            const answer = formData.Q1;
            
            // Build the appropriate flow based on the answer
            if (answer === 'A') {
                // Path A: Need help
                questionFlow = ['Q1', 'Q3', 'Q4', 'Q6', 'Q7', 'Q11', 'Q12', 'Q13', 'Q14', 'email', 'phone', 'community', 'complete'];
            } else if (answer === 'B') {
                // Path B: Have ideas
                questionFlow = ['Q1', 'Q8', 'Q9', 'Q10', 'Q11', 'Q12', 'Q13', 'Q14', 'email', 'phone', 'community', 'complete'];
            } else if (answer === 'C') {
                // Path C: Know exactly
                questionFlow = ['Q1', 'Q2', 'Q5', 'Q11', 'Q12', 'Q13', 'Q14', 'email', 'phone', 'community', 'complete'];
            }
            
            nextQuestion();
        }

        function handleFileUpload(inputId) {
            const fileInput = document.getElementById(inputId);
            const fileInfo = document.getElementById(inputId + '-info');
            
            if (fileInput.files.length > 0) {
                const files = Array.from(fileInput.files);
                const fileNames = files.map(f => f.name).join(', ');
                fileInfo.textContent = `Selected: ${fileNames}`;
                
                const questionId = fileInput.closest('.question-container').dataset.question;
                formData[questionId + '_files'] = files;
                
                // Convert images to base64 for API usage and show preview
                convertFilesToBase64(files, questionId);
                showImagePreviews(files, fileInfo);
            }
        }

        function showImagePreviews(files, fileInfo) {
            // Clear existing previews
            const existingPreviews = fileInfo.parentElement.querySelectorAll('.image-preview');
            existingPreviews.forEach(preview => preview.remove());
            
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'image-preview';
                        previewDiv.style.cssText = 'margin-top: 10px; text-align: center;';
                        previewDiv.innerHTML = `
                            <img src="${e.target.result}" alt="Preview" style="max-width: 200px; max-height: 150px; border: 1px solid #ddd; border-radius: 4px;">
                            <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Preview: ${file.name}</p>
                        `;
                        fileInfo.parentElement.appendChild(previewDiv);
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        async function convertFilesToBase64(files, questionId) {
            const base64Images = [];
            
            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    try {
                        const base64 = await fileToBase64(file);
                        base64Images.push(base64);
                    } catch (error) {
                        console.error('Error converting file to base64:', error);
                    }
                }
            }
            
            if (base64Images.length > 0) {
                formData[questionId + '_base64'] = base64Images;
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        function skipUpload() {
            nextQuestion();
        }

        function skipTextInput() {
            const textarea = document.querySelector('.question-container.active textarea');
            if (textarea) {
                textarea.value = '';
            }
            nextQuestion();
        }

        function skipPhone() {
            formData.phone = '';
            nextQuestion();
        }

        function validateEmail() {
            const emailInput = document.querySelector('.question-container.active input[type="email"]');
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            
            if (emailInput && emailRegex.test(emailInput.value)) {
                // Save email and start generating image early
                formData.email = emailInput.value;
                
                // Start image generation in background
                startBackgroundImageGeneration();
                
                // Show a subtle indicator that generation has started
                showGenerationStartedIndicator();
                
                nextQuestion();
            }
            // Removed alert popup - just don't advance if email is invalid
        }

        let backgroundImagePromise = null;

        async function startBackgroundImageGeneration() {
            try {
                console.log('Starting background image generation...');
                
                // Get API key from config or prompt for it
                let apiKey = window.CONFIG?.OPENAI_API_KEY || window.OPENAI_API_KEY;
                if (!apiKey) {
                    apiKey = prompt('Please enter your OpenAI API key to generate the charm image:');
                    if (!apiKey) {
                        console.log('No API key provided, skipping background generation');
                        return;
                    }
                    window.OPENAI_API_KEY = apiKey;
                }
                
                const responses = captureAllResponses();
                const promptData = generatePromptFromResponses(responses);
                
                // Check if we have uploaded images to incorporate
                const hasUploadedImages = responses.uploaded_images.Q2_images.length > 0 || 
                                        responses.uploaded_images.Q7_images.length > 0 || 
                                        responses.uploaded_images.Q9_images.length > 0;
                
                let promptText;
                let inputContent = [];
                
                if (hasUploadedImages) {
                    // Create prompt that incorporates the uploaded images
                    if (responses.uploaded_images.Q2_images.length > 0) {
                        // Path C: Exact design - make this image into a charm
                        promptText = `Transform this image into a single ${promptData.material} charm with a jump ring. Create two distinct design variations with dimensional, sculptural 2.5D relief: 

DESIGN 1 - Simple Realistic Style: Recreate the main subjects and elements from the image as a raised, dimensional relief design with varying depths and levels. Use realistic proportions and forms with clear depth gradations - foreground elements should be higher relief, background elements in lower relief. Create a sculptural, coin-like appearance with smooth transitions between different height levels. Focus on clear, recognizable 3D forms that capture the essence of the photo.

DESIGN 2 - Simple Cartoonish Style: Transform the subjects from the image into a cute, stylized cartoon version with pronounced 2.5D sculptural relief. Use simplified shapes with exaggerated dimensional features - rounded, puffy forms that pop out from the surface. Create playful depth with cartoon-like bulges, curves, and raised elements. Make it dimensionally charming with clear height variations between different parts of the design.

Both designs must have significant dimensional depth and sculptural relief - NOT flat engravings. Create medal-like, coin-like dimensional quality with varying heights across the surface. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                        
                        // Add the uploaded image(s) to input
                        inputContent.push({
                            "type": "input_text",
                            "text": promptText
                        });
                        
                        responses.uploaded_images.Q2_images.forEach(imageBase64 => {
                            inputContent.push({
                                "type": "input_image",
                                "image_url": imageBase64
                            });
                        });
                    } else {
                        // Path A or B: Combine text preferences with image inspiration
                        // Build detailed user preferences from survey responses
                        let detailedPreferences = `
USER SURVEY RESPONSES TO INCORPORATE:
- Material: ${promptData.material}
- Style: ${promptData.style}
- Subject/Theme: ${promptData.subject}`;

                        if (responses.inspiration) {
                            detailedPreferences += `\n- Story/Inspiration: ${responses.inspiration}`;
                        }
                        if (responses.symbols) {
                            detailedPreferences += `\n- Requested Symbols/Elements: ${responses.symbols}`;
                        }
                        if (responses.style_vibes && responses.style_vibes.length > 0) {
                            detailedPreferences += `\n- Style Vibes: ${responses.style_vibes.join(', ')}`;
                        }
                        if (responses.size_presence) {
                            detailedPreferences += `\n- Size Preference: ${responses.size_presence}`;
                        }
                        if (responses.special_details) {
                            detailedPreferences += `\n- Special Details: ${responses.special_details}`;
                        }

                        promptText = `Create a single ${promptData.subject} charm with a jump ring, combining the user's specific survey responses with inspiration from the reference image(s). Generate 2 distinct style variations with full 3D sculptural relief:

${detailedPreferences}

DESIGN 1 - Simple Style: Create a clean, elegant interpretation that blends the reference images with ALL the user's survey responses above. Use sophisticated, refined forms with smooth sculptural relief and varying depths. Incorporate the requested symbols, story elements, and style preferences while drawing inspiration from the reference images. Full 3D dimensional quality with subtle height variations.

DESIGN 2 - Cartoonish/Cute Style: Transform the same concept into a playful, adorable version with exaggerated cute features. Use rounded, puffy forms that pop out dramatically from the surface. Make it whimsical and charming with pronounced 3D sculptural elements, cartoon-like proportions, and endearing details. Incorporate ALL the user's survey responses (symbols, story, style vibes) while being inspired by the reference images.

Both designs must incorporate ALL the user's stated survey responses while drawing visual inspiration from the reference images. Create full 3D sculptural relief with significant dimensional depth - NOT flat designs. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                        
                        inputContent.push({
                            "type": "input_text", 
                            "text": promptText
                        });
                        
                        // Add inspiration/reference images
                        const allImages = [...responses.uploaded_images.Q7_images, ...responses.uploaded_images.Q9_images];
                        allImages.forEach(imageBase64 => {
                            inputContent.push({
                                "type": "input_image",
                                "image_url": imageBase64
                            });
                        });
                    }
                } else {
                    // No uploaded images - use text-only prompt
                    promptText = `Create a single ${promptData.subject} with ${promptData.style} styling. Material: ${promptData.material}. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.detail}. ${promptData.camera}. Generate 2 different design variations.`;
                    inputContent.push({
                        "type": "input_text",
                        "text": promptText
                    });
                }
                
                console.log('Background generation prompt:', promptText);
                
                // Make separate API calls for each design to ensure we get 2 images
                const design1Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 1 only');
                const design2Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 2 only');
                
                const promises = [];
                
                // Generate Design 1
                promises.push(fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify({
                        model: "gpt-4.1-mini",
                        input: hasUploadedImages ? [{
                            "role": "user",
                            "content": [
                                {
                                    "type": "input_text",
                                    "text": design1Prompt
                                },
                                ...inputContent.filter(item => item.type === "input_image")
                            ]
                        }] : design1Prompt,
                        tools: [{
                            type: "image_generation",
                            quality: "high",
                            size: "1024x1024",
                            background: "opaque"
                        }]
                    })
                }).then(response => response.json()));
                
                // Generate Design 2
                promises.push(fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify({
                        model: "gpt-4.1-mini",
                        input: hasUploadedImages ? [{
                            "role": "user",
                            "content": [
                                {
                                    "type": "input_text",
                                    "text": design2Prompt
                                },
                                ...inputContent.filter(item => item.type === "input_image")
                            ]
                        }] : design2Prompt,
                        tools: [{
                            type: "image_generation",
                            quality: "high",
                            size: "1024x1024",
                            background: "opaque"
                        }]
                    })
                }).then(response => response.json()));
                
                backgroundImagePromise = Promise.all(promises).then(results => {
                    // Combine results into expected format
                    const combinedData = {
                        output: []
                    };
                    
                    results.forEach(result => {
                        if (result.output) {
                            combinedData.output.push(...result.output.filter(output => output.type === "image_generation_call"));
                        }
                    });
                    
                    return combinedData;
                });
                
                console.log('Background image generation started');
                
            } catch (error) {
                console.error('Error starting background image generation:', error);
                backgroundImagePromise = null;
            }
        }

        function showGenerationStartedIndicator() {
            // Add a subtle indicator to the page that generation has started
            const indicator = document.createElement('div');
            indicator.id = 'generation-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #DAE0FF;
                color: #000;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                z-index: 1000;
                border: 1px solid #000;
                animation: fadeInOut 3s ease-in-out;
            `;
            indicator.textContent = 'âœ¨ Generating your charm design...';
            
            // Add fade animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateY(-10px); }
                    20% { opacity: 1; transform: translateY(0); }
                    80% { opacity: 1; transform: translateY(0); }
                    100% { opacity: 0; transform: translateY(-10px); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(indicator);
            
            // Remove after animation
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 3000);
        }

        function validatePhone() {
            const phoneInput = document.querySelector('.question-container.active input[type="tel"]');
            
            if (phoneInput && phoneInput.value.trim()) {
                nextQuestion();
            } else {
                nextQuestion(); // Allow skipping
            }
        }

        function submitForm() {
            // Save final answer
            formData.community = document.querySelector('.question-container.active .option.selected').textContent.trim();
            
            // Generate results summary
            generateResults();
            nextQuestion();
        }

        function generateResults() {
            const resultsList = document.getElementById('resultsList');
            const displayData = {
                'Journey Type': formData.Q1 === 'A' ? 'Exploratory Design' : formData.Q1 === 'B' ? 'Idea Refinement' : 'Direct Creation',
                'Email': formData.email || 'Not provided',
                'Phone': formData.phone || 'Not provided',
                'Material': getOptionText(formData.Q12),
                'Style': getOptionText(formData.Q11),
                'Community Share': formData.community || 'Not specified'
            };
            
            // Add vibe if selected
            if (formData.Q5 || formData.Q10) {
                const vibes = formData.Q5 || formData.Q10;
                if (vibes && vibes.length > 0) {
                    displayData['Vibe'] = vibes.map(v => getVibeText(v)).join(', ');
                }
            }
            
            resultsList.innerHTML = '';
            for (const [key, value] of Object.entries(displayData)) {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${key}:</strong> ${value}`;
                resultsList.appendChild(li);
            }
            
            // Generate and display the charm image
            generateCharmImage();
            
            // Debug: Show captured responses and generated prompt
            console.log('All captured responses:', captureAllResponses());
            console.log('Generated prompt data:', generatePromptFromResponses(captureAllResponses()));
        }

        function captureAllResponses() {
            const responses = {
                journey_type: formData.Q1,
                inspiration: formData.Q3 || formData.Q8,
                recipient: formData.Q4,
                style_vibes: formData.Q5 || formData.Q10 || [],
                symbols: formData.Q6,
                size_presence: formData.Q11,
                material: formData.Q12,
                special_details: formData.Q13,
                email: formData.email,
                phone: formData.phone,
                community_share: formData.community,
                // Include uploaded images
                uploaded_images: {
                    Q2_images: formData.Q2_base64 || [], // Path C: exact design images
                    Q7_images: formData.Q7_base64 || [], // Path A: inspiration images
                    Q9_images: formData.Q9_base64 || []  // Path B: reference images
                }
            };
            return responses;
        }

        function generatePromptFromResponses(responses) {
            // Determine object description based on responses
            let objectDescription = 'elegant charm';
            
            if (responses.symbols) {
                objectDescription = responses.symbols.toLowerCase();
            } else if (responses.inspiration) {
                if (responses.inspiration.includes('moment')) objectDescription = 'commemorative medallion';
                else if (responses.inspiration.includes('person')) objectDescription = 'heart-shaped pendant';
                else if (responses.inspiration.includes('place')) objectDescription = 'compass or map-inspired charm';
                else if (responses.inspiration.includes('curious')) objectDescription = 'geometric charm';
            }
            
            // Determine material based on selection
            let materialType = 'polished reflective gold metal';
            if (responses.material === 'sterling-silver') {
                materialType = 'polished reflective silver metal';
            } else if (responses.material === 'gold-plated') {
                materialType = 'gold-plated silver with warm reflective finish';
            }
            
            // Adjust style based on size preference
            let styleAdjustment = 'high-gloss 3D sculptural metal';
            if (responses.size_presence === 'subtle') {
                styleAdjustment = 'delicate high-gloss 3D sculptural metal with fine details';
            } else if (responses.size_presence === 'bold-sculptural') {
                styleAdjustment = 'bold high-gloss 3D sculptural metal with dramatic presence';
            }
            
            // Incorporate style vibes
            let vibeAdjustment = '';
            if (responses.style_vibes && responses.style_vibes.length > 0) {
                if (responses.style_vibes.includes('elegant')) vibeAdjustment += ', elegant and refined';
                if (responses.style_vibes.includes('bold')) vibeAdjustment += ', bold and confident';
                if (responses.style_vibes.includes('playful')) vibeAdjustment += ', playful and whimsical';
                if (responses.style_vibes.includes('spiritual')) vibeAdjustment += ', meaningful and symbolic';
                if (responses.style_vibes.includes('sweet')) vibeAdjustment += ', sweet and sentimental';
            }

            const prompt = {
                "subject": `a single ${materialType.includes('gold') ? 'gold' : 'silver'} charm in the shape of ${objectDescription}${vibeAdjustment}`,
                "style": styleAdjustment,
                "material": materialType,
                "lighting": "studio lighting with soft reflections and minimal shadows",
                "background": "clean off-white or cream gradient",
                "presentation": "floating product shot, single charm with jump ring attached, angled to show volume and shine",
                "detail": "smooth, rounded surfaces with subtle contours, includes a jump ring for attachment, no engraving or texture",
                "camera": "close-up, eye-level with a slight tilt"
            };
            
            return prompt;
        }

        async function generateCharmImage() {
            try {
                const responses = captureAllResponses();
                const promptData = generatePromptFromResponses(responses);
                
                // Check if we have uploaded images to incorporate
                const hasUploadedImages = responses.uploaded_images.Q2_images.length > 0 || 
                                        responses.uploaded_images.Q7_images.length > 0 || 
                                        responses.uploaded_images.Q9_images.length > 0;
                
                let promptText;
                if (hasUploadedImages) {
                    if (responses.uploaded_images.Q2_images.length > 0) {
                        promptText = `Transform this image into a single ${promptData.material} charm with a jump ring. Create two distinct design variations with dimensional, sculptural 2.5D relief: 

DESIGN 1 - Simple Realistic Style: Recreate the main subjects and elements from the image as a raised, dimensional relief design with varying depths and levels. Use realistic proportions and forms with clear depth gradations - foreground elements should be higher relief, background elements in lower relief. Create a sculptural, coin-like appearance with smooth transitions between different height levels. Focus on clear, recognizable 3D forms that capture the essence of the photo.

DESIGN 2 - Simple Cartoonish Style: Transform the subjects from the image into a cute, stylized cartoon version with pronounced 2.5D sculptural relief. Use simplified shapes with exaggerated dimensional features - rounded, puffy forms that pop out from the surface. Create playful depth with cartoon-like bulges, curves, and raised elements. Make it dimensionally charming with clear height variations between different parts of the design.

Both designs must have significant dimensional depth and sculptural relief - NOT flat engravings. Create medal-like, coin-like dimensional quality with varying heights across the surface. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                    } else {
                        // Build detailed user preferences from survey responses
                        let detailedPreferences = `
USER SURVEY RESPONSES TO INCORPORATE:
- Material: ${promptData.material}
- Style: ${promptData.style}
- Subject/Theme: ${promptData.subject}`;

                        if (responses.inspiration) {
                            detailedPreferences += `\n- Story/Inspiration: ${responses.inspiration}`;
                        }
                        if (responses.symbols) {
                            detailedPreferences += `\n- Requested Symbols/Elements: ${responses.symbols}`;
                        }
                        if (responses.style_vibes && responses.style_vibes.length > 0) {
                            detailedPreferences += `\n- Style Vibes: ${responses.style_vibes.join(', ')}`;
                        }
                        if (responses.size_presence) {
                            detailedPreferences += `\n- Size Preference: ${responses.size_presence}`;
                        }
                        if (responses.special_details) {
                            detailedPreferences += `\n- Special Details: ${responses.special_details}`;
                        }

                        promptText = `Create a single ${promptData.subject} charm with a jump ring, combining the user's specific survey responses with inspiration from the reference image(s). Generate 2 distinct style variations with full 3D sculptural relief:

${detailedPreferences}

DESIGN 1 - Simple Style: Create a clean, elegant interpretation that blends the reference images with ALL the user's survey responses above. Use sophisticated, refined forms with smooth sculptural relief and varying depths. Incorporate the requested symbols, story elements, and style preferences while drawing inspiration from the reference images. Full 3D dimensional quality with subtle height variations.

DESIGN 2 - Cartoonish/Cute Style: Transform the same concept into a playful, adorable version with exaggerated cute features. Use rounded, puffy forms that pop out dramatically from the surface. Make it whimsical and charming with pronounced 3D sculptural elements, cartoon-like proportions, and endearing details. Incorporate ALL the user's survey responses (symbols, story, style vibes) while being inspired by the reference images.

Both designs must incorporate ALL the user's stated survey responses while drawing visual inspiration from the reference images. Create full 3D sculptural relief with significant dimensional depth - NOT flat designs. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.camera}.`;
                    }
                } else {
                    promptText = `Create a single ${promptData.subject} with ${promptData.style} styling. Material: ${promptData.material}. ${promptData.lighting}. ${promptData.background}. ${promptData.presentation}. ${promptData.detail}. ${promptData.camera}. Generate 2 different design variations.`;
                }
                
                console.log('Generated prompt:', promptText);
                console.log('Has uploaded images:', hasUploadedImages);
                
                // Add loading indicator
                const resultsDiv = document.querySelector('.results');
                const loadingDiv = document.createElement('div');
                
                // Check if background generation is available
                if (backgroundImagePromise) {
                    loadingDiv.innerHTML = '<p style="text-align: center; margin: 20px 0;"><em>Finalizing your custom charm design...</em></p>';
                    console.log('Using background-generated image');
                } else {
                    loadingDiv.innerHTML = '<p style="text-align: center; margin: 20px 0;"><em>Generating your custom charm design...</em></p>';
                    console.log('Starting fresh image generation');
                }
                
                loadingDiv.id = 'image-loading';
                resultsDiv.appendChild(loadingDiv);
                
                let data;
                
                // Try to use background-generated image first
                if (backgroundImagePromise) {
                    try {
                        data = await backgroundImagePromise;
                        console.log('Background image ready!');
                    } catch (error) {
                        console.log('Background generation failed, starting fresh:', error);
                        backgroundImagePromise = null;
                    }
                }
                
                // If no background image available, generate fresh
                if (!backgroundImagePromise) {
                    // Get API key from config or prompt for it
                    let apiKey = window.CONFIG?.OPENAI_API_KEY || window.OPENAI_API_KEY;
                    if (!apiKey) {
                        apiKey = prompt('Please enter your OpenAI API key to generate the charm image:');
                        if (!apiKey) {
                            throw new Error('API key required for image generation');
                        }
                        window.OPENAI_API_KEY = apiKey;
                    }
                    
                    let inputContent = [];
                    
                    if (hasUploadedImages) {
                        inputContent.push({
                            "type": "input_text",
                            "text": promptText
                        });
                        
                        if (responses.uploaded_images.Q2_images.length > 0) {
                            responses.uploaded_images.Q2_images.forEach(imageBase64 => {
                                inputContent.push({
                                    "type": "input_image",
                                    "image_url": imageBase64
                                });
                            });
                        } else {
                            const allImages = [...responses.uploaded_images.Q7_images, ...responses.uploaded_images.Q9_images];
                            allImages.forEach(imageBase64 => {
                                inputContent.push({
                                    "type": "input_image",
                                    "image_url": imageBase64
                                });
                            });
                        }
                    } else {
                        inputContent.push({
                            "type": "input_text",
                            "text": promptText
                        });
                    }
                    
                    // Make separate API calls for each design to ensure we get 2 images
                    const design1Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 1 only');
                    const design2Prompt = promptText.replace('Generate 2 distinct style variations', 'Generate DESIGN 2 only');
                    
                    const promises = [];
                    
                    // Generate Design 1
                    promises.push(fetch('https://api.openai.com/v1/responses', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + apiKey
                        },
                        body: JSON.stringify({
                            model: "gpt-4.1-mini",
                            input: hasUploadedImages ? [{
                                "role": "user",
                                "content": [
                                    {
                                        "type": "input_text",
                                        "text": design1Prompt
                                    },
                                    ...inputContent.filter(item => item.type === "input_image")
                                ]
                            }] : design1Prompt,
                            tools: [{
                                type: "image_generation",
                                quality: "high",
                                size: "1024x1024",
                                background: "opaque"
                            }]
                        })
                    }).then(response => response.json()));
                    
                    // Generate Design 2
                    promises.push(fetch('https://api.openai.com/v1/responses', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + apiKey
                        },
                        body: JSON.stringify({
                            model: "gpt-4.1-mini",
                            input: hasUploadedImages ? [{
                                "role": "user",
                                "content": [
                                    {
                                        "type": "input_text",
                                        "text": design2Prompt
                                    },
                                    ...inputContent.filter(item => item.type === "input_image")
                                ]
                            }] : design2Prompt,
                            tools: [{
                                type: "image_generation",
                                quality: "high",
                                size: "1024x1024",
                                background: "opaque"
                            }]
                        })
                    }).then(response => response.json()));
                    
                    const results = await Promise.all(promises);
                    
                    // Combine results into expected format
                    data = {
                        output: []
                    };
                    
                    results.forEach(result => {
                        if (result.output) {
                            data.output.push(...result.output.filter(output => output.type === "image_generation_call"));
                        }
                    });
                }
                
                // Remove loading indicator
                const loading = document.getElementById('image-loading');
                if (loading) loading.remove();
                
                // Extract image data from response
                const imageGenerationCalls = data.output?.filter(output => output.type === "image_generation_call") || [];
                
                if (imageGenerationCalls.length > 0) {
                    const imageTypeText = hasUploadedImages ? 
                        (responses.uploaded_images.Q2_images.length > 0 ? 
                            'Based on your uploaded design' : 
                            'Inspired by your reference images') : 
                        'Generated from your preferences';
                    
                    const generationMethod = backgroundImagePromise ? 
                        'Pre-generated while you completed the questionnaire' : 
                        'Generated fresh for your design';
                    
                    // Display header
                    const headerDiv = document.createElement('div');
                    headerDiv.innerHTML = `
                        <h4 style="margin: 20px 0 10px 0; color: #000;">Your Custom Charm Designs:</h4>
                        <p style="font-size: 14px; color: #666; margin-bottom: 15px;"><strong>${imageTypeText}</strong></p>
                    `;
                    resultsDiv.appendChild(headerDiv);
                    
                    // Create container for side-by-side layout
                    const imagesContainer = document.createElement('div');
                    imagesContainer.style.cssText = 'display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;';
                    
                    // Display each generated image
                    imageGenerationCalls.forEach((call, index) => {
                        if (call.result) {
                            // Convert base64 to blob URL for display
                            const base64Data = call.result;
                            const byteCharacters = atob(base64Data);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: 'image/png' });
                            const imageUrl = URL.createObjectURL(blob);
                            
                            const imageDiv = document.createElement('div');
                            imageDiv.style.cssText = 'flex: 1; min-width: 250px; padding: 15px; border: 1px solid #eee; border-radius: 8px; text-align: center;';
                            
                            // Determine design type based on path and index
                            let designType;
                            if (responses.uploaded_images.Q2_images.length > 0) {
                                // Path C: Exact picture - realistic vs cartoonish of the exact image
                                designType = index === 0 ? 'Simple Realistic' : 'Simple Cartoonish';
                            } else {
                                // Path A/B: Image+text combination - simple vs cute interpretations
                                designType = index === 0 ? 'Simple Style' : 'Cartoonish/Cute Style';
                            }
                            imageDiv.innerHTML = `
                                <h5 style="margin: 0 0 10px 0; color: #000;">Design ${index + 1}: ${designType}</h5>
                                <img src="${imageUrl}" alt="Generated charm design ${index + 1}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px;">
                            `;
                            imagesContainer.appendChild(imageDiv);
                        }
                    });
                    
                    resultsDiv.appendChild(imagesContainer);
                    
                    // Add footer info
                    const footerDiv = document.createElement('div');
                    footerDiv.innerHTML = `
                        <p style="font-size: 14px; color: #666; margin: 15px 0 10px 0;"><strong>Prompt used:</strong> ${promptText}</p>
                        <p style="font-size: 12px; color: #999;">Generated using GPT Image 1 (latest model)</p>
                        <p style="font-size: 11px; color: #aaa; margin-top: 5px;">${generationMethod}</p>
                    `;
                    resultsDiv.appendChild(footerDiv);
                } else {
                    throw new Error('No images generated');
                }
                
            } catch (error) {
                console.error('Error generating image:', error);
                
                // Remove loading indicator
                const loading = document.getElementById('image-loading');
                if (loading) loading.remove();
                
                // Show error message
                const resultsDiv = document.querySelector('.results');
                const errorDiv = document.createElement('div');
                errorDiv.innerHTML = `
                    <p style="color: #666; text-align: center; margin: 20px 0;">
                        <em>Image generation temporarily unavailable. We'll still create your custom design manually!</em>
                    </p>
                `;
                resultsDiv.appendChild(errorDiv);
            }
        }

        function getOptionText(value) {
            const mapping = {
                'subtle': 'Subtle & delicate',
                'bold-sculptural': 'Bold & sculptural',
                'classic': 'Classic & balanced',
                'not-sure': 'Not sure yet',
                '14k-gold': '14K Solid Gold',
                'sterling-silver': 'Sterling Silver (925)',
                'gold-plated': 'Gold-Plated Silver',
                'help-decide': 'Help me decide'
            };
            return mapping[value] || value;
        }

        function getVibeText(value) {
            const mapping = {
                'elegant': 'Elegant & Timeless',
                'bold': 'Bold & Confident',
                'playful': 'Playful & Cute',
                'spiritual': 'Spiritual & Symbolic',
                'sweet': 'Sweet & Sentimental'
            };
            return mapping[value] || value;
        }

        // Enable continue button and auto-advance for text inputs
        document.querySelectorAll('textarea, input[type="email"], input[type="tel"]').forEach(input => {
            input.addEventListener('input', function() {
                const continueBtn = this.closest('.question-container').querySelector('.btn-primary');
                if (continueBtn) {
                    continueBtn.disabled = this.value.trim() === '';
                }
                
                // Clear any existing timer
                clearTimeout(window.textInputTimer);
                
                // Auto-advance for required fields after user stops typing
                if (this.type === 'email' && this.value.trim() !== '') {
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (emailRegex.test(this.value)) {
                        window.textInputTimer = setTimeout(() => {
                            validateEmail();
                        }, 1500);
                    }
                } else if (this.closest('[data-question="Q8"]') && this.value.trim() !== '') {
                    // Auto-advance for Q8 (required text field)
                    window.textInputTimer = setTimeout(() => {
                        nextQuestion();
                    }, 2000);
                }
            });
            
            // Handle Enter key for immediate advancement
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    if (this.tagName === 'TEXTAREA') {
                        e.preventDefault();
                    }
                    const continueBtn = this.closest('.question-container').querySelector('.btn-primary');
                    if (continueBtn && !continueBtn.disabled) {
                        continueBtn.click();
                    }
                }
            });
        });

        // Initialize
        showQuestion('Q1');
        addArrowToButtons();
    </script>
</body>
</html>